---
title: "仓颉文档阅读-开发指南III: 基础数据类型(I)"
pubDate: "2025-10-24 14:25:12"
description: "仓颉文档阅读的开发指南部分, 本篇文章介绍一些仓颉语言的一些基本操作符"
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250929154944807.webp'
categories: 
    - Blogs
tags:
    - 开发语言
    - 仓颉
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

import Question from "../../components/mdx/Question.astro";

<Info>

阅读文档版本:

语言规约 [Cangjie-0.53.18-Spec](https://cangjie-lang.cn/docs?url=/0.53.18/Spec/source_zh_cn/Chapter_01_Lexical_Structure(zh).html)

具体开发指南 [Cangjie-LTS-1.0.3](https://cangjie-lang.cn/docs?url=/1.0.3/index.html)

在阅读 了解仓颉的语言规约时, 难免会涉及到一些仓颉的示例代码, 但 我们对仓颉并不熟悉, 所以可以用[仓颉在线体验](https://cangjie-lang.cn/playground)快速验证

有条件当然可以直接[配置Canjie-SDK](https://cangjie-lang.cn/download/1.0.1)

</Info>

<Warning>

博主在此之前, 基本就只接触过C/C++语言, 对大多现代语言都没有了解, 所以在阅读过程中遇到相似的概念, 难免会与C/C++中的相似概念作类比, 见谅

</Warning>

<Warning>

在阅读仓颉编程语言的开发指南之前, 已经大概阅读了一遍 仓颉编程语言的语言规约，已经对仓颉编程语言有了一个大概的了解

所以在阅读开发指南时，不会对类似：类、函数、结构体、接口等解释起来较为复杂名称 做出解释

</Warning>

> 此样式内容, 表示文档原文内容

## 基础数据类型

### 基本操作符

> 操作符是执行特定的数学运算或逻辑操作的符号。例如，数学运算符号的加号（`+`）可将两个数相加（如：`let i = 1 + 2`），逻辑操作符号的逻辑与（`&&`）可用于组合并确保多个条件判断均满足（如：`if (i > 0 && i < 10)`）
> 
> 仓颉编程语言不仅支持各种常用的操作符，同时为了减少常见编码错误对它们做了部分改进
> 
> 如：赋值表达式（包含赋值操作符的表达式）的类型是 `Unit`，值是`()`，如果将 `if(a == 3)` 写成 `if(a = 3)`，赋值表达式的返回值不是布尔类型，因此会编译报错，这样可以避免将判等操作符（`==`）误写成赋值操作符（`=`）的问题
> 
> 算术操作符（`+`、`-`、`*`、`/`、`%` 等）的结果会被检测并**禁止值溢出**，以此来避免保存变量时由于变量大于或小于其类型所能承载的范围时导致的异常结果
> 
> 仓颉编程语言还提供了区间操作符，例如 `a..b` 或 `a..=b`，这方便表达一个区间内的数值
> 
> 本章节只描述了仓颉编程语言中的基本操作符，其他操作符参见附录中的[操作符]
> 
> 如何进行自定义类型的操作符重载参见[操作符重载]章节

仓颉对于`=`赋值操作符特别规定，赋值表达式的类型和值, 恒为`Unit`和`()`

这表示，仓颉中基础数据的赋值表达式是**禁止连续赋值**的, 因为单个赋值表达式的值恒为`()`

#### 赋值操作符`=`

> 用于将左操作数的值修改为右操作数的值，要求右操作数的类型是左操作数类型的**子类型**
> 
> 对赋值表达式求值时，总是先计算 `=` 右边的表达式，再计算 `=` 左边的表达式，最后进行赋值
> 
> ```cangjie
> main(): Int64 {
>     var a = 1
>     var b = 1
>     a = (b = 0)             // 编译错误，赋值表达式的类型是 Unit，值是 ()
>     
>     if (a = 5) {            // 编译错误，赋值表达式的类型是 Unit，值是 ()
>     }
>     
>     a = b = 0               // 语法错误，不支持链式使用赋值
> 
>     return 0
> }
> ```
> 
> 多赋值表达式是一种特殊的赋值表达式，多赋值表达式等号左边必须是一个 `tuple（元组）`，这个 `tuple` 里面的元素必须都是左值，等号右边的表达式也必须是 `tuple` 类型，右边 `tuple` 每个元素的类型必须是对应位置左值类型的子类型
> 
> 值得注意的是当左侧 `tuple` 中出现 `_` 时，表示忽略等号右侧 `tuple` 对应位置处的求值结果（意味着这个位置处的类型检查总是可以通过的）
> 
> 多赋值表达式可以将右边的 `tuple` 类型的值，一次性赋值给左边 `tuple` 内的对应左值，省去逐个赋值的代码
> 
> ```cangjie
> main(): Int64 {
>     var a: Int64
>     var b: Int64
>     (a, b) = (1, 2)         // a = 1, b = 2
>     (a, b) = (b, a)         // 交换, a = 2, b = 1
>     (a, _) = (3, 4)         // a = 3
>     (_, _) = (5, 6)         // 无赋值
>     
>     return 0
> }
> ```

赋值操作符`=`, 可以将`=`右边表达式的值 赋值给 `=`左边的表达式， 总是先计算右边的表达式, 且右边表达式的值要**为左边表达式的子类型**

仓颉还可以使用元组，对多个变量一次性进行赋值:

```cangjie
(变量1, 变量2, ...) = (值1, 值2, ...)
```

但要保证，按照编码顺序，变量类型与值类型保持一直或值为变量子类型

左边元组中的变量，可以使用通配符`_`代替, 对应位置将不会出现变量赋值

#### 算术操作符`-`、`+`、`-`、`*`、`/`、`%`、`**`

> 仓颉编程语言支持的算术操作符包括：一元负号（`-`）、加（`+`）、减（`-`）、乘（`*`）、除（`/`）、取余（`%`）、求幂（`**`）
> 
> 除了一元负号是一元前缀操作符，其他操作符均是二元中缀操作符
> 
> 一元负号（`-`）的操作数只能是数值类型的表达式
> 
> 一元前缀负号表达式的值等于操作数取负的值，类型和操作数的类型相同：
> 
> ```cangjie
> let num1: Int64 = 8
> let num2 = -num1              // num2 = -8, 其数据类型为“Int64”
> let num3 = -(-num1)           // num3 = 8, 其数据类型为“Int64”
> ```
> 
> 对于二元操作符 `*`、`/`、`%`、`+` 和 `-`，要求两个操作数的类型相同
> 
> 其中 `%` 的操作数只支持整数类型；`*`、`/`、`+` 和 `-` 的操作数可以是任意数值类型
> 
> > 注意：
> > 
> > - 除法（`/`）的操作数为整数时，将非整数值向 `0` 的方向舍入为整数
> > 
> > - 整数取余运算 `a % b` 的值定义为 `a - b * (a / b)`
> > 
> > - 加法操作符也可用于字符串的拼接
> 
> ```cangjie
> let a = 2 + 3                 // a = 5
> let b = 3 - 1                 // b = 2
> let c = 3 * 4                 // c = 12
> let d = 7 / 3                 // d = 2
> let e = 7 / -3                // e = -2, 当遇到“-”时，它具有更高的优先级
> let f = -7 / 3                // f = -2
> let g = -7 / -3               // g = 2, 当遇到“-”时，它具有更高的优先级
> let h = 4 % 3                 // h = 1
> let i = 4 % -3                // i = 1, 当遇到“-”时，它具有更高的优先级
> let j = -4 % 3                // j = -1
> let k = -4 % -3               // k = -1, 当遇到“-”时，它具有更高的优先级
> 
> let s1 = "abc"
> var s2 = "ABC"
> let r1 = s1 + s2              // r1 = "abcABC"
> ```

仓颉中的算术操作符，要保证**操作数类型完全相同**

算术操作符的`-`、`+`、`-`、`*`, 都没有什么需要特别注意的，就是小学的四则运算，但要注意优先级，不确定的可以使用`()`

`+`可以用于字符串之间的拼接

其他的有一定需要注意的特性：

1. **`/`**, 除 只有一点需要注意

    如果运算数为整数, 运算结果**将小数部分向`0`的方向舍入**

    即，如果结果是负数, 整数部分`+1`小数部分舍去; 如果结果是正数，小数部分舍去

2. **`%`**, 取余 操作数只能为整型，且需要了解正确的计算方式

    **`a - b * (a / b)`**

> **`**`** 表示求幂运算（如 `x**y` 表示计算底数 `x` 的 `y` 次幂）
> 
> `**` 的左操作数只能为 `Int64` 类型或 `Float64` 类型
> 
> > 注意：
> > 
> > 当左操作类型为 `Int64` 时，右操作数只能为 `UInt64` 类型，表达式的类型为 `Int64`
> > 
> > 当左操作类型为 `Float64` 时，右操作数只能为 `Int64` 类型或 `Float64` 类型，表达式的类型为 `Float64`
> 
> ```cangjie
> let p1 = 2 ** 3                     // p1 = 8
> let p2 = 2 ** UInt64(3 ** 2)        // p2 = 512
> let p3 = 2.0 ** 3                   // p3 = 8.0
> let p4 = 2.0 ** 3 ** 2              // p4 = 512.0
> let p5 = 2.0 ** 3.0                 // p5 = 8.0
> let p6 = 2.0 ** 3.0 ** 2.0          // p6 = 512.0
> ```

求幂操作符`**`, 是C/C++中不存在的操作符, `x**y` 表示计算底数 `x` 的 `y` 次幂

作为幂 的操作数:

在底为`Int64`类型时，只能为`UInt64`类型

在底为`Float64`类型时，只能为`Int64`和`Float64`类型

#### 复合赋值操作符

> 仓颉编程语言也提供 `**=`、`*=`、`/=`、`%=`、`+=`、`-=`、`<<=`、`>>=`、`&=`、`^=`、`|=`、`&&=` 和 `||=` 复合赋值操作符
> 
> 对于复合赋值表达式求值时，总是先计算 `=` 左边的表达式的左值，再根据这个左值取右值，然后将该右值与 `=` 右边的表达式做计算（若有短路规则会继续遵循短路规则），最后赋值
> 
> 因为复合赋值表达式也是一个赋值表达式，所以复合赋值操作符也是**非结合的**
> 
> 复合赋值表达式同样要求两个操作数的类型相同
> 
> ```cangjie
> var a: Int64 = 10
> a += 2              // a = 12
> a -= 2              // a = 10
> a **= 2             // a = 100
> a *= 2              // a = 200
> a /= 10             // a = 20
> a %= 6              // a = 2
> a <<= 2             // a = 8
> ```

复合赋值操作符，总是先对`=`左边的表达式取值，再对`=`右边的表达式取值，然后将左值与右值根据复合操作符进行计算, 最后赋值给左边变量

#### 关系操作符

> 关系操作符包括六种：相等（`==`）、不等（`!=`）、小于（`<`）、小于等于（`<=`）、大于（`>`）、大于等于（`>=`）
> 
> 关系操作符都是二元操作符，并且要求两个操作数的类型是一样的
> 
> 关系表达式的类型是 `Bool` 类型，即值只可能是 `true` 或 `false`
> 
> 关系表达式举例：
> 
> ```cangjie
> main(): Int64 {
>     3 < 4                                   // true
>     3 <= 3                                  // true
>     3 > 4                                   // false
>     3 >= 3                                  // true
>     3.14 == 3.15                            // false
>     3.14 != 3.15                            // true
>     return 0
> }
> ```
> 
> 对于元组类型，当且仅当所有元素均支持使用 `==` 进行值判等（使用 `!=` 进行值判不等）时，此元组类型才支持使用 `==` 进行值判等（使用 `!=` 进行值判不等）
> 
> 否则，此元组类型不支持 `==` 和 `!=`（如果使用 `==` 和 `!=`，编译报错）
> 
> 两个同类型的元组实例相等，当且仅当相同位置（`index`）的元素全部相等（意味着它们的长度相等）
> 
> ```cangjie
> var isTrue: Bool = (1, 3) == (0, 2)         // false
> isTrue = (1, "123") == (1.0, 2)             // 编译错误，两个操作数的类型不一致
> isTrue = (1, _) == (1.0, _)                 // 编译错误，通配符不可作为元组中元素进行匹配
> ```
> 

仓颉的关系操作符的关系表达式，类型是`Bool`值只能为`true`和`false`, 且操作数的类型只能是相同类型

`==`和`!=`, 还可以用于元组之间，但**两个元组的对应`index`的元素类型要相同，且元组的所有元素都需要已经支持`==`和`!=`**

#### `coalescing`操作符

> `coalescing` 操作符使用 **`??`** 表示，`??` 是**二元中缀操作符**
> 
> `coalescing` 操作符用于 `Option` 类型的解构
> 
> `e1 ?? e2` 表达式，在 `e1` 的值等于 `Option<T>.Some(v)` 时，`e1 ?? e2` 的值等于 `v` 的值（此时，不会再去对 `e2` 求值，即满足 “短路求值”）；在 `e1` 的值等于 `Option<T>.None` 时，`e1 ?? e2` 的值等于 `e2` 的值
> 
> `coalescing` 表达式使用举例：
> 
> ```cangjie
> main(): Int64 {
>     let v1 = Option<Int64>.Some(100)
>     let v2 = Option<Int64>.None
>     let r1 = v1 ?? 0
>     let r2 = v2 ?? 0
>     print("${r1}")                      // 100
>     print("${r2}")                      // 0
>     return 0
> }
> ```

