---
title: "仓颉文档阅读-语言规约II: 名字、作用域、变量、修饰符"
pubDate: "2025-09-24"
description: "一直对仓颉挺感兴趣的, 但是一直没有去读一下文档, 慢慢看一看, 了解一下"
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250918180424875.webp'
categories: 
    - Blogs
tags:
    - 开发语言
    - 仓颉
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

<Info>

阅读文档版本:

语言规约 [Cangjie-0.53.18-Spec](https://cangjie-lang.cn/docs?url=/0.53.18/Spec/source_zh_cn/Chapter_01_Lexical_Structure(zh).html)

具体开发指南 [Cangjie-LTS-1.0.1](https://cangjie-lang.cn/docs?url=/1.0.1/index.html)

在阅读 了解仓颉的语言规约时, 难免会涉及到一些仓颉的示例代码, 但 我们对仓颉并不熟悉, 所以可以用[仓颉在线体验](https://cangjie-lang.cn/playground)快速验证

有条件当然可以直接[配置Canjie-SDK](https://cangjie-lang.cn/download/1.0.1)

</Info>

<Warning>

博主在此之前, 基本就只接触过C/C++语言, 对大多现代语言都没有了解, 所以在阅读过程中遇到相似的概念, 难免会与C/C++中的相似概念作类比, 见谅

</Warning>

> 此样式内容, 表示文档原文内容

## 名字、作用域、变量、修饰符

> 本章首先介绍名字、作用域、遮盖，然后介绍其中一种名字——变量，包括变量的定义和初始化，最后是修饰符

这里有一个名词: 遮盖, 猜测 可能是C/C++中嵌套作用域出现同名变量的情况

### 名字

> 仓颉编程语言中，我们用**名字**（names）标识变量、函数、类型、package、module 等实体（entities）
>
> **名字**必须是一个合法的[标识符](https://www.humid1ch.cn/blog/cangjie-docs-reading-i#heading-1)
>
> 仓颉编程语言的关键字、变量、函数、类型（包括：`class`、`interface`、`struct`、`enum`、`type alias`）、泛型参数、`package` 名、`module` 名共用同一个**命名空间**，即，在同一个 `scope` 声明或定义的实体，不允许同名（除了构成重载的名字）
>
> 不同 `scope` 声明或定义的实体允许同名，但可能产生 `shadow`
>
> ```cangjie
> let f2 = 77
> 
> func f2() {				// Error， function name is the same as the variable f2
>     print("${f2}")
> }     
> 
> // Variable, function, type names cannot be the same as keywords 
> let Int64 = 77			// Error: 'Int64' is a keyword
> 
> func class() {			// Error: class is a keyword
>     print("${f2}")
> }    
> 
> main(): Int64 {  
>     print("${f2}")		// Print 77
> 
>     let f2 = { =>		// Shadowed the global variable f2
>        print("10")
>     }
>     f2()
>     return 1
> }
> ```

需要注意的就是, 同作用域不能出现同名名字

绝大多数语言应该都是如此吧

### 作用域

> 对一个实体，在其名字所在的**作用域**(`scope`)中**可以直接使用名字访问**，不需要通过前缀限定词访问
>
> 作用域是可嵌套的，一个作用域包含自身以及自身包含的嵌套的作用域
>
> 名字在其嵌套作用域中如果**没有被遮盖或覆盖**，也可以直接使用名字访问

#### 块

> 在仓颉语言中，由一对匹配的大括号及其中可选的表达式声明序列组成的结构被称之为**块**（block）
>
> 块在仓颉语言中无处不在，例如函数定义的函数体、`if` 表达式的两个分支、`while` 表达式的循环体，都是块
>
> **块会引出新的作用域**
>
> 块的语法定义为：
>
> ```
> block
>     : '{' expressionOrDeclarations '}'
>     ;
> ```
>
> 块拥有值, 块的值由其中的表达式与声明序列确定
>
> **对块进行求值时，会按表达式和变量声明在块中的顺序进行**
>
> **若块的最后一项是表达式，当该表达式求值完毕后，该表达式的值即为该块的值**：
>
> ```cangjie
> {
>     let a = 1
>     let b = 2
>     a + b
> } // a + b的值就是此块的值
> ```
>
> 若块的最后一项是声明，当该声明处理完毕后，该块的值为 `()`:
>
> ```cangjie
> {
>     let a = 1
> } // () 是此块的值
> ```
>
> 若块中不含有任何表达式或声明，该块的值为 `()`：
>
> ```cangjie
> { } // () 是此块的值
> ```

**仓颉中块也是存在值的**, 且**与块内的最后一个执行的表达式有关**

类型应该也是吧? 值为`()`的块的类型是`Unit`?

