---
title: "仓颉文档阅读-语言规约V: 函数(II)"
pubDate: "2025-09-30 15:13:16"
description: "一直对仓颉挺感兴趣的, 但是一直没有去读一下文档, 慢慢看一看, 了解一下"
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250929154944807.webp'
categories: 
    - Blogs
tags:
    - 开发语言
    - 仓颉
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

import Question from "../../components/mdx/Question.astro";

<Info>

阅读文档版本:

语言规约 [Cangjie-0.53.18-Spec](https://cangjie-lang.cn/docs?url=/0.53.18/Spec/source_zh_cn/Chapter_01_Lexical_Structure(zh).html)

具体开发指南 [Cangjie-LTS-1.0.1](https://cangjie-lang.cn/docs?url=/1.0.1/index.html)

在阅读 了解仓颉的语言规约时, 难免会涉及到一些仓颉的示例代码, 但 我们对仓颉并不熟悉, 所以可以用[仓颉在线体验](https://cangjie-lang.cn/playground)快速验证

有条件当然可以直接[配置Canjie-SDK](https://cangjie-lang.cn/download/1.0.1)

</Info>

<Warning>

博主在此之前, 基本就只接触过C/C++语言, 对大多现代语言都没有了解, 所以在阅读过程中遇到相似的概念, 难免会与C/C++中的相似概念作类比, 见谅

</Warning>

> 此样式内容, 表示文档原文内容

## 函数

> 函数是一段完成特定任务的独立代码片段，可以通过函数名字来标识，这个名字可以被用来调用函数
>
> 仓颉编程语言中函数是**一等公民**，函数可以赋值给变量，或作为参数传递，或作为返回值返回

### `Lambda`表达式

> 一个 `Lambda` 表达式是一个匿名的函数
> 
> `Lambda` 表达式的语法如下：
> ```
> lambdaExpression    
>         : '{' NL* lambdaParameters? '=>' NL* expressionOrDeclarations '}'
>         ;
> 
> lambdaParameters
>     : lambdaParameter (',' lambdaParameter)* ','?
>     ;
> 
> lambdaParameter
>     : (identifier | '_') (':' type)?
>     ;
> ```
> 
> `lambda` 表达式有两种形式，一种是有形参的 `{a: Int64 => e1; e2 }`
> 
> 另一种是无形参的 `{ => e1; e2 }` (e1 和 e2 是表达式或声明序列)
> 
> ```cangjie
> let f1: (Int64, Int64)->Int64 = {a: Int64, b: Int64 => a + b}
> 
> var f2: () -> Int32 = { => 123 }
> ```

现代语言中基本都存在`lambda`表达式

仓颉中的`lambda`表达式的书写并不复杂:

```cangjie
{ 形参列表 => 表达式序列 }
```

仓颉的`lambda`表达式, 语法规定 形参列表不用`()`包裹, 执行的语句序列也不用`{}`包裹

> 对于有形参的 `lambda` 表达式，可以使用一个 `_` 代替一个形参，`_` 代表在 `lambda` 的函数体中不会使用 到的参数
> 
> ```cangjie 
> let f2 = { n: Int64, _: Int64 => return n * n }
> let f3: (Int32, Int32) -> Int32 = { n, _ => return n * n }
> let f4: (String) -> String = { _ => return "Hello" }
> ```


> `Lambda` 表达式中不支持声明返回类型
> 
> 若上下文明确指定了 `lambda` 表达式的返回类型，则其返回类型为上下文指定的类型
> 
> 如果指定的返回类型是 `Unit`，则仓颉编译器还会在 `lambda` 表达式的函数体中所有可能返回的地方插入 `return ()`，使其总是返回 `Unit` 类型
> 
> 指定了 `Unit` 返回类型的示例如下：
> 
> ```cangjie
> func column(c: (Data) -> Unit) {...}
> func row(r: (Data) -> Unit) {...}
> 
> func build(): Unit {
>     column { _ =>
>         row { _ =>
>             buildDetail()
>             buildCalendar()
>         } // OK. 由于插入了'return'，所以类型正确
>         width(750)
>         height(700)
>         backgroundColor("#ff41444b")
>     }  // OK. 由于插入了'return'，所以类型正确
> }
> ```
> 
> 若不存在这样的上下文，则 `=>` 右侧的表达式的类型会被视为 `lambda` 表达式的返回类型
> 
> 同函数一样，若无法推导出返回类型，则会编译报错

仓颉中的`lambda`表达式不支持声明返回值类型

如果`lambda`表达式的上下文中指定了返回值类型, 那么编译器也会在`lambda`表达式的可能返回的位置插入`return`表达式, 这一点和函数是一样的

如果不存在相关的上下文, 那么就将`=>`右侧的表达式类型当作`lambda`表达式的返回类型, 这里的右侧 是指`lambda`表达式会执行的完整的表达式序列的类型

> `Lambda` 表达式中参数的类型标注可缺省，编译器会尝试从上下文进行类型推断，当编译器无法推断出类型时会编译报错
> 
> ```cangjie
> var sum1: (Int32, Int32) -> Int32 = {a, b => a + b}
> 
> var sum2: (Int32, Int32) -> Int32 = {a: Int32, b => a + b}
> 
> var display = { => print("Hello") }
> 
> var a = { => return 1 }
> ```
> 
> `=>` 右侧的内容与普通函数体的规则一样，同样可以省略 `return`
> 
> 若 `=>` 的右侧为空，返回值为 `()`
> 
> ```cangjie
> sum1 = {a, b => a + b}
> 
> sum2 = {a, b => return a + b}		// 与前面的一行一致
> ```
> 
> `Lambda` 表达式支持原地调用，例如：
> ```cangjie
> let r1 = {a: Int64, b: Int64 => a + b}(1, 2)  // r1 = 3
> let r2 = { => 123 }()                         // r2 = 123
> ```

仓颉中`lambda`表达式的原地调用, 类似将整个`lambda`表达式当作函数名, 直接加上`(实参列表)`就可以调用

### 闭包

> 闭包指的是自包含的函数或 `lambda`
> 
> 闭包可以从定义它的静态作用域中**捕获**变量，即使对闭包调用不在定义的作用域，仍可访问其捕获的变量
> 
> 变量捕获发生在闭包定义时

自包含, 表示自己内部包含有 部分或全部 执行所需的数据, 不需要完全依赖调用时传入的参数执行

当一个函数或`lambda`被定义时, 如果你在函数体或`lambda`执行体中引用了 在定义位置所在静态作用域中 能够访问到的变量, 这些变量会被自动捕获到闭包中

被捕获的变量, 会被包含到函数或`lambda`中, 此时形成闭包

其实可以类比C++中的`lambda`表达式的手动捕获可见变量功能, 不过C++需要手动捕获

> 不是所有闭包内的变量访问都称为捕获，以下情形的变量访问不是捕获：
> 
> - 对定义在本函数或本 `lambda` 内的局部变量的访问；
> 
> - 对本函数或本 `lambda` 的形参的访问；
> 
> - 全局变量和静态成员变量在函数或 `lambda` 中的访问；
> 
> - 实例成员变量在实例成员函数中的访问
> 
>     由于实例成员函数将`this`作为参数传入，在实例成员函数内通过`this`访问所有实例成员变量
> 
> 关于变量的捕获，可以分为以下两种情形：
> 
> - 捕获`let`声明的变量：
> 
>     在闭包中不能修改这些变量的值
> 
>     如果捕获的变量是引用类型，可修改其可变实例成员变量的值
> 
>     仅捕获了`let`声明的**局部变量**的函数或 `lambda` 可以作为一等公民使用，即可以赋值给变量，可以作为实参或返回值使用，可以作为表达式使用
> 
> - 捕获`var`声明的变量：
> 
>     捕获了可变变量的函数或 `lambda` 只能被调用，不能作为一等公民使用，包括不能赋值给变量，不能作为实参或返回值使用，不能作为表达式使用
> 
> > 需要注意的是，捕获具有传递性，如果一个函数`f`调用了捕获`var`变量的函数`g`，且存在`g`捕获的`var`变量不在函数`f`内定义，那么函数`f`同样捕获了`var`变量，此时，`f`也不能作为一等公民使用
> 
> 以下示例中，`h`仅捕获了`let`声明的变量`y`，`h`可以作为一等公民使用
> 
> ```cangjie
> func f(){    
>     let y = 2
>     func h() {
>         print(y)  // OK, 捕获了不可变变量
>     }
>     let d = h     // OK, h 可以被赋值到变量
> 
>     return h      // OK, h 可以被当做返回值
> }
> ```
> 
> 以下示例中，`g`捕获了`var`声明的变量`x`，`g`不可以作为一等公民使用，**仅能被调用**
> 
> ```cangjie
> func f() {
>     var x = 1
> 
>     func g() {
>         print(x)  // OK, 捕获了一个可变变量
>     }
>     let b = g     // Error, g 不能被赋值到变量
>     
>     g     // Error, g 不能用作表达式
>     g()   // OK, g 可以被调用
>     
>     // Lambda 捕获了一个可变变量，不能赋值给变量
>     let e = { => print("${x}") }  // Error
> 
>     let i = { => x * x }()        // OK, Lambda 捕获了一个可变变量, 可以被调用
> 
>     return g                      // Error, g 不能用作返回值
> }
> ```
> 
> 以下示例中，`g`捕获了`var`声明的变量`x`，`f`调用了`g`，且`g`捕获的`x`不在`f`内定义，`f`同样不能作为一等公民使用：
> 
> ```cangjie
> func h(){
>     var x = 1
>     
>     func g() { x }    // 捕获了一个可变变量
>     
>     func f() {
>         g()           // 调用 g
>     }
> 
>     return f          // error
> }
> ```
> 
> 以下示例中，`g`捕获了`var`声明的变量`x`，`f`调用了`g`
> 
> 但`g`捕获的`x`在`f`内定义，`f`没有捕获其它`var`声明的变量
> 
> 因此，`f`仍作为一等公民使用：
> 
> ```cangjie
> func h(){
>     func f() {
>         var x = 1
>         func g() { x }    // 捕获一个可变变量
> 
>         g()
>     }
> 
>     return f              // ok
> }
> ```
> 
> 访问了`var`修饰的全局变量、静态成员变量、实例成员变量的函数或 `lambda` 仍可作为一等公民使用
> 
> ```cangjie
> class C {
>     static var a: Int32 = 0
>     static func foo() {
>         a++                   // OK
>         return a
>     }
> }
> 
> var globalV1 = 0
> 
> func countGlobalV1() {
>     globalV1++
>     C.a = 99
>     let g = C.foo             // OK
> }
> 
> func g(){
>     let f = countGlobalV1     // OK
>     f()
> }
> ```

对全局变量、静态变量的访问不被看作捕获

从文档介绍来看, 如果先忽略捕获的传递性, 那么 只要函数或`lambda`捕获了`var`变量, 那么此闭包就只能调用
