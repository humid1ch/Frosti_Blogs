---
title: "仓颉文档阅读-语言规约II: 类型"
pubDate: "2025-09-18"
description: "一直对仓颉挺感兴趣的, 但是一直没有去读一下文档, 慢慢看一看, 了解一下"
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250918180424875.webp'
categories: 
    - Blogs
tags:
    - 开发语言
    - 仓颉
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

import Diff from "../../components/mdx/Diff.astro";

import Kbd from "../../components/mdx/Kbd.astro";

<Info>

阅读文档版本:

语言规约 [Cangjie-0.53.18-Spec](https://cangjie-lang.cn/docs?url=/0.53.18/Spec/source_zh_cn/Chapter_01_Lexical_Structure(zh).html)

具体开发指南 [Cangjie-LTS-1.0.1](https://cangjie-lang.cn/docs?url=/1.0.1/index.html)

在阅读 了解仓颉的语言规约时, 难免会涉及到一些仓颉的示例代码, 但 我们对仓颉并不熟悉, 所以可以用[仓颉在线体验](https://cangjie-lang.cn/playground)快速验证

有条件当然可以直接[配置Canjie-SDK](https://cangjie-lang.cn/download/1.0.1)

> 此样式内容, 表示文档原文内容

</Info>

## 类型

> 仓颉编程语言是一种**静态类型（statically  typed）**语言：大部分保证程序安全的类型检查发生在编译期
>
> 同时，仓颉编程语言是一种**强类型（strongly  typed）**语言：每个表达式都有类型，并且表达式的类型决定了它的取值空间和它支持的操作
>
> 静态类型和强类型机制可以帮助程序员在编译阶段发现大量由类型引发的程序错误

静态类型语言, 表示 代码的类型检查发生在编译期, 在编译期就需要确定好每个变量的实际类型, 即如果代码中存在类型的不匹配等错误, 会在编译期就报错

强类型语言, 说明 仓颉可能会禁止很多或许很常见的隐式类型转换

用C语言和仓颉举一个最简单的例子:

```c
// C语言
#include <stdio.h>

int main() {
    int intVal = 30;
    intVal += 30.0;
    printf("intVal: %d\n", intVal);

    return 0;
}
```

```cangjie
// Cangjie
main(): Int64 {
    var intVal = 30
    intVal += 30.3
    println(intVal)

    return 0
}
```

这两段代码, C语言是可以编译通过 并可以运行的:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250919161902248.webp)

但是, 仓颉就无法编译通过:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250919170800806.webp)

仓颉无法编译通过的原因是, **不能将浮点值隐式转换为`Int64`类型**

但是, 如果显式进行类型转换, 就可以:

```cangjie
main(): Int64 {
    var intVal = 30
    intVal += Int64(30.3)
    println(intVal)

    return 0
}
```

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250919170925285.webp)

文档中还提到, 仓颉每个表达式都有类型, 也就是说表达式也禁止隐式类型转换

就像, C/C++中你可以将表达式`1 + 1`当作`true`使用, 但仓颉中`1 + 1`不能被当作`true`, 只能使用布尔类型中的`true`和`false`表示真和假

### 可变类型 和 不可变类型

> 仓颉中的类型可分为两类：不可变类型（immutable type）和可变类型（mutable type）
>
> 其中，不可变类型包括数值类型（分为整数类型和浮点数类型）、`Rune` 类型、`Bool` 类型、`Unit` 类型、`Nothing` 类型、`String` 类型、元组（`Tuple`）类型、`Range` 类型、函数（`Function`）类型、`enum` 类型
>
> 可变类型包括 `Array` 类型、`VArray` 类型、`struct` 类型、`class` 类型和 `interface` 类型
>
> 不可变类型和可变类型的区别在于：不可变类型的值，其数据值一经初始化后就不会发生变化；可变类型的值，其数据值初始化后仍然有可以修改的方法

对于基本只接触过C/C++的我来说, 我想真心的发问 可变类型和不可变类型是什么?

不可变类型的值，其数据值一经初始化后就不会发生变化?? 可变类型的值，其数据值初始化后仍然有可以修改的方法??

在C/C++中, 对于一个普通变量, 定义好之后 可以随便修改这个变量的值啊? 难道仓颉不是吗?

经过了解, 发现还真不是, 而且不少现代语言中 都存在可变类型和不可变类型

不可变类型的值, 其数据值一经初始化后就不会发生变化

这表示, **不可变类型定义一个变量, 用一个值给变量初始化之后, 这个值就无法改变了:**

**如果你再给这个变量赋值, 本质上并不是用一个新值替换了这个变量中的旧值, 而是创建了一个新的同名变量存储了新值**

这与C/C++不同, C/C++中定义一个变量之后, 如果对这个变量进行赋值等操作, 都是向这个变量的原内存空间 存入新的值, 变量的地址无论是实际上还是逻辑上, 都没有发生改变

而现代语言中, **这种不可变类型的变量, 如果给变量赋值, 事实上就是创建了一个新的同名变量存储新的值, 变量的地址从逻辑上是会发生变化的**, 但现代语言基本不提供查看实际地址的操作, 要想查看地址可能会比较复杂, 所以一般无法观测

而可变类型, 就可以看作C/C++中的普通变量, 对象的内存是不改变的, 只是修改值

### 不可变类型

#### 数值类型

> 数值类型包括整数类型与浮点数类型，分别用于表示整数和浮点数
>
> 整数类型包含有符号（signed）整数类型和无符号（unsigned）整数类型
>
> 其中，有符号整数类型包括 `Int8`、`Int16`、`Int32`、`Int64` 和 `IntNative`，分别用于表示编码长度为 `8-bit`、`16-bit`、`32-bit`、`64-bit` 和平台相关大小的有符号整数值的类型；
>
> 无符号整数类型包括 `UInt8`、`UInt16`、`UInt32`、 `UInt64` 和 `UIntNative`，分别用于表示编码长度为 `8-bit`、`16-bit`、`32-bit`、 `64-bit` 和平台相关大小的无符号整数值的类型
>
> 浮点数类型包括 `Float16`、`Float32` 和 `Float64`，分别用于表示编码长度为 `16-bit`、`32-bit` 和 `64-bit` 的浮点数的类型
>
> **`IntNative/UIntNative` 的长度与当前系统的位宽一致**

仓颉语言中 整型和浮点型属于不可变类型

| 类型         | 范围                                                         |
| ------------ | ------------------------------------------------------------ |
| `Int8`       | **−2<sup>7</sup> ∼ 2<sup>7</sup>−1 (-128 to 127)**           |
| `Int16`      | **−2<sup>15</sup> ∼ 2<sup>15</sup>−1 (-32768 to 32767)**     |
| `Int32`      | **−2<sup>31</sup> ∼ 2<sup>31</sup>−1 (-2147483648 to 2147483647)** |
| `Int64`      | **−2<sup>63</sup> ∼ 2<sup>63</sup>−1 (-9223372036854775808 to 9223372036854775807)** |
| `IntNative`  | 平台相关                                                     |
| `UInt8`      | **0 ∼ 2<sup>8</sup>−1 (0 to 255)**                           |
| `UInt16`     | **0 ∼ 2<sup>15</sup>−1 (0 to 65535)**                        |
| `UInt32`     | **0 ∼ 2<sup>31</sup>−1 (0 to 4294967295)**                   |
| `UInt64`     | **0 ∼ 2<sup>63</sup>−1 (0 to 18446744073709551615)**         |
| `UIntNative` | 平台相关                                                     |
| `Float16`    | 详情见 IEEE754 Binary16 格式                                 |
| `Float32`    | 详情见 IEEE754 Binary32 格式                                 |
| `Float64`    | 详情见 IEEE754 Binary64 格式                                 |

> 1. `Byte` 类型作为 `UInt8` 的类型别名，`Byte` 与 `UInt8` 完全等价。
> 2. `Int/UInt` 类型分别作为 `Int64/UInt64` 的类型别名，`Int` 与 `Int64` 完全等价，`UInt` 与 `UInt64` 完全等价。

除了表中的类型, 还可以用`Byte`替代`UInt`, 用`Int`代替`Int64`, 用`UInt`代替`UInt64`

##### 数值类型字面量

详细的表述, 在[阅读仓颉文档的第一篇文章](https://www.humid1ch.cn/blog/cangjie-docs-reading-i#heading-5)中 有涉及仓颉中的整型字面量 和 浮点类型字面量

> 浮点类型量中有几个特殊的值需要注意：正无穷（`POSITIVE_INFINITY`），负无穷（`NEGATIVE_INFINITY`），Not a Number（`NaN`），正 `0`（`+0.0`），负 `0`（`-0.0`）
>
> 其中，无穷表示操作结果超出了表示范围，例如将两个很大的浮点数相乘，或将一个非零浮点数除以浮点零时，其结果都是无穷，无穷的符号由操作数的符号决定，符合“正负得负，负负得正”的规律
>
> `NaN` 表示既不是实数也不是无穷的情况，例如计算正无穷乘以 `0` 的结果就是 `NaN`

> 仓颉编程语言中的浮点小数类型的最小正值为非正规浮点小数 (subnormal floating point number)。
>
> 对于 `Float32` 类型最小可表示的正浮点数为 2<sup>−149</sup>，大约为 `1.4e-45`；而最大值可表示的数为 (2 − 2<sup>−23</sup>)×2<sup>127</sup>，大约为`3.40282e38`
>
> 对于 `Float64` 类型最小可表示的正浮点数为 2<sup>−1074</sup>，大约为 `4.9e-324`；而最大可表示的数为 (2 − 2<sup>−52</sup>)×2<sup>1023</sup>，大约为 `1.79769e308`

> 当非 0 的浮点小数字面值因过小或者过大而舍入得到 0 或者无穷，那么编译器会告警

##### 数值类型支持的操作符

> 数值类型支持的操作符包括：算术操作符、位操作符、关系操作符、自增（减）操作符、一元负号操作符和（复合）赋值操作符
>
> 其中浮点类型不支持位操作符



> **算术操作符**包括加（`+`）、减（`-`）、乘（`*`）、除（`/`）、取余（`%`）、取幂（`**`）
>
> 默认算术操作符没有被重载的情况下，**要求算术操作符的两个操作数的类型必须相同**，如果要将两个不同类型的操作数进行操作，必须先进行强制类型转换

这一句表述, 其实也是 仓颉语言是一种强类型语言的一种体现

在算术操作符没有重载的情况下, 即 操作符功能是默认的情况下, 操作符两边的**操作数的类型要一致**

这里的一致, 不仅仅是只 整型 或 浮点型, 还有具体类型也要一致, 即 如果一个操作数为`Int32` 则 另一个操作数也必须是`Int32`

下面这段代码, 就会出现问题:

```cangjie
package First

main(): Int64 {
    var int32Val: Int32 = 30
    var int64Val: Int64 = 30
    var intVal = int32Val + int64Val

    return 0
}
```

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250920003859554.webp)

错误: 二元操作符`+`的操作数为`Int32`和`Int64`两种类型, 不合法

> **位操作符** 包括位求反（`!`）、左移（`<<`）、右移（`>>`）、位与（`&`）、位异或（`^`）、位或（`|`）

> **关系操作符**包括小于（`<`）、大于（`>`）、小于等于（`<=`）、大于等于（`>=`）、相等（`==`）、不等（`!=`），关系表达式的结果是一个 `Bool` 类型的值（`true` 或 `false`）

仓颉中关系表达式的结果是`Bool`类型的, 可以作为判断条件使用

> **自增（减）操作符**包括自增（`++`）和自减（`--`），可看做是一种特殊的赋值操作符（见下），用于实现将变量值加（减）1
>
> **自增（减）操作符只能作为后缀操作符使用**，且只能作用于整数类型可变变量，因为不可变变量和整数字面量的值不允许修改

与C/C++中的`++`和`--`不同, **仓颉语言中的`++`和`--`只能后置**

**仓颉中的`++`和`--`只能操作 整型可变变量, 即 `var`修饰定义的整型变量**

文章提到, 更详细的说明, 在关于表达式的内容中有介绍

> **一元负号操作符**使用 `-` 表示，结果是对其操作数取负

> **（复合）赋值操作符**包括赋值（`=`）和复合赋值操作（`op=`），其中 `op` 可以是算术操作符、逻辑操作符和位操作符中的任意二元操作符
>
> （复合）赋值操作可以实现一个值为数值类型的表达式到数值类型变量的赋值

###### 浮点数类型支持的操作符

> 浮点类型支持的操作包括（注意没有位操作）：算术操作、关系操作、自增（减）操作、一元正（负）号操作、条件操作和（复合）赋值操作
>
> 浮点数的计算可能使用与其本身类型不同精度的操作
>
> 浮点操作中有几种特殊情况需要注意：**在关系表达式中，如果有操作数的值为 `NaN`，则表达式的结果为 `false`，除了 `NaN != x` 与 `x != NaN` 的结果为 `true`（`x` 可以是包括 `NaN` 在内的任意浮点数）**

浮点操作中, 大多与整形操作一致, 但浮点类型数据中存在`NaN`

所以, 关系表达式中存在值为`NaN`的变量的话, 有特定的结果计算方式:

```cangjie
package First

main(): Int64 {
    let val = 30.0
    if (val == Float64.NaN) {
        println("val == NaN")
    }

    if (val != Float64.NaN) {
        println("val != NaN")
    }

    return 0
}
```

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250920010311744.webp)

<Info>

仓颉在`std.math`包中, 提供了接口, 可以获取不同浮点精度的`NaN`

</Info>

#### `Rune`类型

> 仓颉编程语言使用 `Rune` 类型表示 `Unicode code point` 
>
> 这些值可分为可打印字符、非打印字符（不可显示的字符，如控制符）、特殊字符（如单引号和反斜线）

`Rune`类型, 就是仓颉中的单字符类型

`Rune`类型的值是`Unicode`字符集中的字符, `Rune`类型代表一个完整的`Unicode`码位

`Unicode`字符集中, 除了基础的`ASCII`码符号, 还有中文和`emoji`表情等, 所以`Rune`占用的大小肯定不是1字节

关于`Rune`字面量可以阅读[上一篇文章中相关内容](https://www.humid1ch.cn/blog/cangjie-docs-reading-i#heading-12)

> `Rune` 类型的字面量由一对单引号和字符组成，如：
>
> ```cangjie
> 'S'
> '5'
> ' ' 
> ```
>
> 非打印和特殊的字符型字面量使用转义字符（`\`）定义：
>
> | escape character | character                                                    |
> | :--------------- | :----------------------------------------------------------- |
> | `\0`             | Empty character                                              |
> | `\\`             | backslash `\`                                                |
> | `\b`             | Backspace                                                    |
> | `\f`             | Writer                                                       |
> | `\n`             | newline                                                      |
> | `\r`             | Enter                                                        |
> | `\t`             | Horizontal tab                                               |
> | `\v`             | Vertical tab                                                 |
> | `\’`             | single quotation mark `’`                                    |
> | `\”`             | double quotation marks `”`                                   |
> | `\u{X}`          | Any Unicode code point, where `X` is a 1-8 digit hexadecimal number |

> `Rune` 类型仅支持关系操作符（根据 `Unicode code point` 编码进行比较）。
>
> ```cangjie
> main() {
>     'A'=='A' 	// result: true
>     'A'!='A' 	// result: false
>     'A'<'a' 	// result: true
>     'A'<='A' 	// result: true
>     'A'>'a' 	// result: false
>     'A'>='A' 	// result: true
>     
>     return 0
> }
> ```

C/C++语言中, 用`char`类型表示单个字符, `char`本质是整型, 所以可以进行整型的算术运算

而仓颉中, **明确`Rune`不可以进行非关系操作符的任何运算**

#### `Bool`类型

