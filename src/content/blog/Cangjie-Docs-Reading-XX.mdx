---
title: "仓颉文档阅读-语言规约XI: 包和模块管理"
pubDate: "2025-10-14 18:26:44"
description: "一直对仓颉挺感兴趣的, 但是一直没有去读一下文档, 慢慢看一看, 了解一下"
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250929154944807.webp'
categories: 
    - Blogs
tags:
    - 开发语言
    - 仓颉
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

import Question from "../../components/mdx/Question.astro";

<Info>

阅读文档版本:

语言规约 [Cangjie-0.53.18-Spec](https://cangjie-lang.cn/docs?url=/0.53.18/Spec/source_zh_cn/Chapter_01_Lexical_Structure(zh).html)

具体开发指南 [Cangjie-LTS-1.0.1](https://cangjie-lang.cn/docs?url=/1.0.1/index.html)

在阅读 了解仓颉的语言规约时, 难免会涉及到一些仓颉的示例代码, 但 我们对仓颉并不熟悉, 所以可以用[仓颉在线体验](https://cangjie-lang.cn/playground)快速验证

有条件当然可以直接[配置Canjie-SDK](https://cangjie-lang.cn/download/1.0.1)

</Info>

<Warning>

博主在此之前, 基本就只接触过C/C++语言, 对大多现代语言都没有了解, 所以在阅读过程中遇到相似的概念, 难免会与C/C++中的相似概念作类比, 见谅

</Warning>

> 此样式内容, 表示文档原文内容

---

终于到包和模块管理了

## 包和模块管理

> 在仓颉编程语言中，程序以包的形式进行组织，**包是最小的编译单元**
> 
> 包可以定义子包，从而构成树形结构
> 
> 没有父包的包称为 `root` 包，`root` 包及其子包（包括子包的子包）构成的整棵树称为 `module`
> 
> `module` 的名称与 `root` 包相同
> 
> `module` 是仓颉的最小发布单元
> 
> 包由一个或多个源码文件组成，**同一个包的源码文件必须在同一个目录**，并且**同一个目录里的源码文件只能属于同一个包**
> 
> 子包的目录是其父包目录的子目录

仓颉中, 包可以拥有子包, 没有父包就是`root`包, `root`包及其子包构成整个`module`

`module` 是仓颉的最小发布单元, 包是最小编译单元

### 包

#### 包的声明


> 包声明以关键字 `package` 开头，后接 `root` 包至当前包路径上所有包的包名，以 `.` 分隔（路径本身不是包名）
> 
> 包声明的语法如下：
> 
> ```cangjie
> packageHeader
>     : packageModifier? (MACRO NL*)? PACKAGE NL* fullPackageName end+
>     ;
> 
> fullPackageName
>     : (packageNameIdentifier NL* DOT NL*)* packageNameIdentifier
>     ;
> 
> packageNameIdentifier
>     : Ident
>     | contextIdent
>     ;
> 
> packageModifier
>     : PUBLIC
>     | PROTECTED
>     | INTERNAL
>     ;
> ```
> 
> 每个包都有包名，包名是这个包可唯一识别的标识符
> 
> 除 `root` 包外，包名必须和其所在的目录名一致
> 
> **包声明必须在文件的首行**（注释和空白字符不计），每个文件**只能有一个 `package` 声明**
> 
> 特别地，`root` 包的文件可以不声明 `package`，对于不包含 `package` 声明的文件，它会用 `default` 作为包名
> 
> ```cangjie
> // ./src/main.cj
> // 省略包声明相当于'package default'
> 
> main() {
>     println("Hello World")
> }
> ```
> 
> `package` 可以被 `internal`、`protected` 或者 `public` 修饰
> 
> `package` 的默认修饰符（默认修饰符是指在省略情况下的修饰符语义，这些默认修饰符也允许显式写出）为 `public`
> 
> 同一个包在不同文件中的 `package` 声明必须使用相同的访问修饰符修饰
> 
> 特别地，`root` 包不能被 `internal` 或者 `protected` 修饰
> 
> - **`internal` 表示仅当前包及子包（包括子包的子包）内可见**
> 
>     当前包的子包（包括子包的子包）内可以导入这个包或者这个包的成员
> 
> - **`protected` 表示仅当前 `module` 内可见**
> 
>     同一个 `module` 内的其它包可以导入这个包或者这个包的成员，不同 `module` 的包无法访问
> 
> - **`public` 表示 `module` 内外均可见**
> 
>    其它包可以导入这个包或者这个包的成员

仓颉中, 声明包的语法是`包修饰词 package 包名`

在`.cj`文件中声明包, 就表示此文件属于所声明的包, 当然 前提是目录结构合法

如果不显式声明包, 则 `package default`

### 包的成员

> 包的成员是在顶层声明的类、接口、`struct`、`enum`、类型别名、全局变量、扩展、函数
> 
> 当前包的父包和子包 并不是当前包的成员，**访问父包或者子包需要 包的导入机制**，未被导入的包名不在 `top-level` 作用域中
> 
> 如下所示的例子中，`package a.b` 是 `package a` 的子包
> 
> ```cangjie
> // src/a.cj
> package a
> let a = 0                 // ok
> 
> // src/b/b.cj
> package a.b
> let a = 0                 // ok
> let b = 0                 // ok
> ```
> 
> 如下所示的例子中，`package a.b` 是 `package a` 的子包
> 
> ```cangjie
> // src/a.cj
> package a
> 
> let u = 0                 // ok
> let _ = b.x               // Error: 未声明的标识符 'b'
> let _ = a.u               // Error: 未声明的标识符 'a'
> let _ = a.b.x             // Error: 未声明的标识符 'a'
> 
> // src/b/b.cj
> package a.b
> 
> let x = 1                 // ok
> let _ = a.u               // Error: 未声明的标识符 'a'
> let _ = a.b.x             // Error: 未声明的标识符 'a'
> let _ = b.x               // Error: 未声明的标识符 'b'
> ```
> 
> 特别地，**子包不能和当前包的成员同名**，这是为了保证访问路径中的名称是唯一的

不能尝试通过当前包的包名访问当前包的成员

### 访问修饰符


> 仓颉中，可以使用访问修饰符来保护对类型、变量、函数等元素的访问
> 
> 仓颉有 4 种不同的访问修饰符
> 
> - `private`
> 
> - `internal`
> 
> - `protected`
> 
> - `public`

这四种访问修饰符, 并不只是修饰包用的

#### 修饰顶层元素


> 在修饰顶层元素时不同访问修饰符的语义如下：
> 
> - **`private` 表示仅当前文件内可见**
> 
>     不同的文件无法访问这类成员
> 
> - **`internal` 表示仅当前包及子包（包括子包的子包）内可见**
> 
>     同一个包内可以不导入就访问这类成员，当前包的子包（包括子包的子包）内可以通过导入来访问这类成员
> 
> - **`protected` 表示仅当前 `module` 内可见**
> 
>     同一个包的文件可以不导入就访问这类成员，不同包但是在同一个 `module` 内的其它包可以通过导入访问这些成员，不同 `module` 的包无法访问
> 
> - **`public` 表示 `module` 内外均可见**
> 
>     同一个包的文件可以不导入就访问这类成员，其它包可以通过导入访问这些成员
> 
> |   | File | Package & Sub-Packages | Module | All Packages |
> | - | ---- | ---------------------- | ------ | ------------ |
> | `private` | Y | N | N | N |
> | `internal` | Y | Y | N | N |
> | `protected` | Y | Y | Y | N |
> | `public` | Y | Y | Y | Y |
> 
> 不同顶层声明支持的访问修饰符和默认修饰符规定如下：
> 
> - `pacakge` 支持使用 `internal`、`protected`、`public`，默认修饰符为 `public`
> 
> - `import` 支持使用全部访问修饰符，默认修饰符为 `private`
> 
> - 其他顶层声明支持使用全部访问修饰符，默认修饰符为 `internal`

除`internal`之外, C++中也存在另外三个修饰词, 但 C++中的访问修饰符是用于类成员的, 用来声明成员可访问性

仓颉中的访问修饰符, 还可以修饰包成员的可访问性

#### 修饰非顶层成员

> 在修饰非顶层成员时不同访问修饰符的语义如下：
> 
> **`private` 表示仅当前类型或扩展定义内可见**
> 
> **`internal` 表示仅当前包及子包（包括子包的子包）内可见**
> 
> **`protected` 表示当前 `module` 及当前类的子类可见**
> 
> **`public` 表示 `module` 内外均可见**
> 
> |   | Type/Extend | Package & Sub-Packages | Module & Sub-Classes | All Packages |
> | - | ----------- | ---------------------- | -------------------- | ------------ |
> | `private` | Y | N | N | N |
> | `internal` | Y | Y | N | N |
> | `protected` | Y | Y | Y | N |
> | `public` | Y | Y | Y | Y |
> 
> 类型成员的访问修饰符 可以不同于 类型本身
> 
> 除接口外类型成员的默认修饰符（默认修饰符是指在省略情况下的修饰符语义，这些默认修饰符也允许显式写出）是 `internal`
> 
> 接口中的成员函数和属性**不可以写访问修饰符**，它们的访问级别等同于 `public`

包内可见, 即表示 在此包内定义的实例, 可以通过实例访问类成员

`protected`是`module`以及子类可以见的, 也就表示 如果不同属一个`module`, 此类成员是无法访问的

`protected`和`internal`, 这两个修饰符, 在刚接触包可能会出现混淆:

一个是`module`及子类可见, 一个是当前包及子包可见, 但`module`就是一个包含父子关系的包链, 那么这两个有什么区别?

区别在于, `protected`修饰类成员, 父包也是可见的, 而`internal`只能当前包和子包

而`private`和`public`则是两个极端, 只类内可见 或 全部可见没有限制

#### 访问修饰符的合法性检查

> 仓颉的访问级别排序为 `public` > `protected` > `internal` > `private`
> 
> 类型的访问级别：
> 
> - 非泛型类型的访问级别 由 类型声明的访问修饰符 决定
> 
> - 泛型实例化类型的访问级别等同于该泛型类型与该泛型类型实参的访问级别中最低的一个
> 
> 一个声明的访问修饰符 不得高于 该声明中用到的类型的访问修饰符的级别
> 
> 具体地：
> 
> - 变量、属性声明的访问级别不得高于其类型的访问级别
> 
> - 函数声明的访问级别不得高于参数类型、返回值类型，以及 `where` 约束中的类型上界的访问级别
> 
> - 类型别名的访问级别不得高于原类型的访问级别
> 
> - 类型声明的访问级别不得高于 `where` 约束中的类型上界的访问级别
> 
> - 子包的访问级别不得高于其父包的访问级别
> 
> - `import` 的访问修饰符不得高于其导入声明的访问级别
> 
> ```cangjie
> private open class A {}
> 
> protected let a = A()                     // error: 使用 private 类型 A, 声明 protected 变量 a
> let (a, b) = (A(), 1)                     // error: 使用 private 类型 A, 声明 internal 变量 a
> 
> func f(_: A) {}                           // error: 使用 private 类型 A, 声明 internal 函数 f
> func f() { A() }                          // error: 使用 private 类型 A, 声明 internal 函数 f
> func f<T>() where T <: A {}               // error: 使用 private 类型 A, 声明 internal 函数 f
> 
> public type X = A                         // error: 使用 private 类型 A, 声明 public 类型 X
> public type ArrayA = Array<A>             // error: 使用 private 类型 A, 声明 public 类型 ArrayA
> 
> protected struct S<T> where T <: A {}     // error: 使用 private 类型 A, 约束 protected struct S<T>
> 
> // src/a.cj
> public package a
> 
> // src/a/b/b.cj
> protected package a.b                     // ok
> 
> // src/a/b/c/c.cj
> public package a.b.c                      // error
> ```

当你在使用一个类型时, 可能使用这个类型进行 定义变量、声明别名、导入此包 等

这些操作也可以使用访问修饰符修饰, 所以你不能 在进行这些操作的时候 尝试使用更大权限的修饰符去进行提权

> 特别地，类继承时 子类访问级别 与 父类访问级别、类型实现/继承接口时 子类型访问级别 与 父接口访问级别 **不受上述规则限制**
> 
> ```cangjie
> private open class A {}
> public enum E { U | V }
> interface I {}
> 
> public class C <: A {}                    // ok
> 
> public interface J <: I {}                // ok
> 
> extend E <: I {}                          // ok
> ```
