---
title: "仓颉文档阅读-语言规约V: 函数(I)"
pubDate: "2025-09-29 16:30:10"
description: "一直对仓颉挺感兴趣的, 但是一直没有去读一下文档, 慢慢看一看, 了解一下"
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250929154944807.webp'
categories: 
    - Blogs
tags:
    - 开发语言
    - 仓颉
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

import Question from "../../components/mdx/Question.astro";

<Info>

阅读文档版本:

语言规约 [Cangjie-0.53.18-Spec](https://cangjie-lang.cn/docs?url=/0.53.18/Spec/source_zh_cn/Chapter_01_Lexical_Structure(zh).html)

具体开发指南 [Cangjie-LTS-1.0.1](https://cangjie-lang.cn/docs?url=/1.0.1/index.html)

在阅读 了解仓颉的语言规约时, 难免会涉及到一些仓颉的示例代码, 但 我们对仓颉并不熟悉, 所以可以用[仓颉在线体验](https://cangjie-lang.cn/playground)快速验证

有条件当然可以直接[配置Canjie-SDK](https://cangjie-lang.cn/download/1.0.1)

</Info>

<Warning>

博主在此之前, 基本就只接触过C/C++语言, 对大多现代语言都没有了解, 所以在阅读过程中遇到相似的概念, 难免会与C/C++中的相似概念作类比, 见谅

</Warning>

> 此样式内容, 表示文档原文内容

## 函数

> 函数是一段完成特定任务的独立代码片段，可以通过函数名字来标识，这个名字可以被用来调用函数
>
> 仓颉编程语言中函数是**一等公民**，函数可以赋值给变量，或作为参数传递，或作为返回值返回

函数嘛, C/C++中很熟悉了

但是现代语言中应该新增了很多特性, 逐步了解

### 函数定义

> 仓颉编程语言中，函数的定义遵循以下语法规则：
>
> ```
> functionDefinition
>     : functionModifierList? 'func'
>     identifier 
>     typeParameters?
>     functionParameters
>     (':' type)?
>     (genericConstraints)?
>     block
>     ;
> ```
>
> 可以总结为如下：
>
> - 通过关键字`func`来定义一个函数
> - `func`前可以用函数修饰符进行修饰
> - `func`后需要带函数名
> - 可选的类型形参列表，类型形参列表由`<>`括起，多个类型形参之间用`,`分隔
> - 函数的参数由`()`括起，多个参数用`,`分隔，并且需要给定每个参数的参数类型
> - 可缺省的函数返回类型，由`:type`表示
> - 函数定义时必须有函数体，函数体是一个块（不包含函数形参）
>
> 以下示例是一个完整的函数定义具备的所有要素，它没有使用访问修饰符 `public` 修饰表示其在包内部可访问，函数名为 `foo`，有一个 `Int64` 类型的参数`a`，有返回类型`Int64`，有函数体
>
> ```
> func foo(a: Int64): Int64 { a }
> ```
>
> 函数名不能被进行赋值，即函数名不能以表达式左值的形式在程序中出现
>
> 如以下示例中的操作是禁止的
>
> ```cangjie
> func f(a: Int64): Int64 { a }
> // f = {a: Int64 => a + 1}		// compile-time error
> ```

仓颉中, 函数的定义直观表示是这样的:

```cangjie
修饰符 func 函数名<类型参数列表(可选)>(函数参数列表): 返回值类型 {
    函数体
}
// 类型参数列表格式为: <T1, T2, T3>
// 函数参数列表可为空, 不为空格式为: (param1: Type, param2: Type, ...)
```

#### 函数修饰符

##### 全局函数的修饰符

> 全局函数可以被所有访问修饰符修饰，默认的可访问性为 `internal`
>
> 详细内容请参考包和模块管理章节[访问修饰符]

全局函数是属于包的, 相关的修饰, 应该在包管理相关内容中有介绍

##### 局部函数的修饰符

> 局部函数无可用修饰符

仓颉允许在函数内定义函数, 不过不能用修饰符

##### 成员函数的修饰符

> 类成员函数可用修饰符有：`public`, `protected`, `private`, `internal`, `static`, `open`, `override`, `redef`详见[类的成员]以及包和模块管理章节[访问修饰符]
>
> 接口成员函数可用修饰符有： `static`，`mut`, 详见[接口成员]
>
> `struct` 成员函数可用修饰符有：`mut`，`public`，`private`，`internal`，`static`，详见[struct 类型]
>
> `enum` 成员函数可用修饰符有：`public`，`private`，`internal`，`static`，详见[enum 类型]
>
> 如果不提供可访问修饰符，接口成员函数以外的成员函数可以在当前包及子包内被访问，接口成员函数默认是 `public` 语义

`struct`和`enum`类型在语言规约之前的文档中有提及, 但是并无修饰符的具体介绍, 所以应该还是在类相关内容中

### 参数

> 函数定义时参数列表中参数的顺序：**非命名参数，命名参数**（包括：不带默认值命名参数和带默认值的参数）
>
> 参数列表的语法定义如下：
>
> ```
> functionParameters
>  : ('(' (unnamedParameterList (',' namedParameterList)? )? ')')
>    | ('(' (namedParameterList)? ')')
>  ;
> 
> nondefaultParameterList
>  : unnamedParameter (',' unnamedParameter)* (',' namedParameter)*
>  | namedParameter (',' namedParameter)*
>  ;
> 
> namedParameterList
>  : (namedParameter | defaultParameter) (',' (namedParameter | defaultParameter))*
>  ;
> 
> namedParameter
>  : identifier '!' ':' type 
>  ;
> 
> defaultParameter
>  : identifier '!' ':' type '=' expression
>  ;
> 
> unnamedParameterList
>  : unnamedParameter (',' unnamedParameter)*
>  ;
> 
> unnamedParameter
>  : (identifier | '_') ':' type
>  ;
> ```
>

仓颉中, 函数的参数类型有两种: 非命名参数 和 命名参数

且**命名参数可以存在默认值**, 对应 C++函数参数中的缺省值

> 对于非命名参数，可以使用一个 `_` 代替一个函数体中不会使用到的参数
>
> ```cangjie
> func bar(a: Int64 , b!: Float64 = 1.0, s!: String) {}				// OK
> func bar2(a: Int64 = 1, b!: Float64 = 1.0, s: String = "Hello") {}	// Error
> func foo(a: Int64, b: Float64)(s: String = "Hello") {}				// Error
> 
> func f1(a: Int64, _: Int64): Int64 {
>     return a + 1
> }
> 
> func f2(_: String): Unit {
>     print("Hello Cangjie")
> }
> ```
>
> 函数参数均为不可变变量，即均有 `let` 修饰，在函数定义内不能对其进行赋值
>
> ```cangjie
> func foo(a: Int64, b: Float64) {
>     a = 1       // Error: 参数'a'是不可变的，不能被赋值
>     b = 1.0     // Error: 参数'b'是不可变的，不能被赋值
> }
> ```
>
> 函数的参数类型不受下述“是否是命名形参”、“是否有默认值”的影响；
>
> 且讨论参数类型时，一个类型与它的 `alias` 被视为相同的类型

函数定义例子中有两个错误示例:

1. **非命名参数不允许设置初始值**
2. **命名参数之后, 不允许再出现非命名参数**

**仓颉中函数的参数均为不可变类型, 是不允许赋值的**

#### 命名形参

> 函数定义时通过 **在形参名后添加 `!` 来定义命名形参**
>
> ```
> namedParameter
>     : identifier '!' ':' type
>     ;
> ```
>
> - 函数定义时，命名形参后不允许有非命名形参
>
>     ```cangjie
>     func add1(a: Int32, b!: Int32): Int32 { a + b } // ok
>     
>     func add2(a!: Int32, b: Int32): Int32 { a + b } // error
>     ```
>
> - 当形参被定义成命名形参后，调用这个函数时，则**必须在实参值前使用`参数名：`前缀来指定这个实参对应的形参**，否则编译报错
>
>     ```cangjie
>     func add(a: Int32, b!: Int32): Int32 { a + b }
>     
>     add(1, b: 2) // ok
>     add(1, 2)    // error
>     ```
>
> - 如果抽象函数或 `open` 修饰的函数有命名形参，那么实现函数或 `override` 修饰的函数也需要保持同样的命名形参
>
>     ```cangjie
>     open class A {
>         public open func f(a!: Int32): Int32 {
>             return a + 1
>         }
>     }
>     class B <: A {
>         public override func f(a!: Int32): Int32 { // ok
>             return a + 1
>         }
>     }
>     class C <: A {
>         public override func f(b!: Int32): Int32 { // error
>             return b + 1
>         }
>     }
>     ```

仓颉中, 如果函数存在命名参数, 则必须通过`参数名: 值`来进行传参

#### 参数的默认值

> 函数的参数可以有默认值，通过`=`来为参数定义默认值
>
> 当默认值被定义后，调用这个函数**可以忽略这个参数**，函数体会使用默认值
>
> 为了便于理解，有默认值的参数称为**可选参数**
>
> 函数定义时，**可选参数是一种命名形参，可选参数名后必须添加`!`**，否则编译报错；
>
> ```
> defaultParameter
>     : identifier '!' ':' type '=' expression
>     ;  
> ```
>
> 如下示例，我们定义了一个`add`函数，它的参数类型列表`(Int32, Int32)`
>
> 函数定义时，`b`具有默认值`1`
>
> 因此，当我们调用`add`函数，并且只传递一个值`3`时，`3`会被赋值给`a`，从而返回结果`4`
>
> 如果传入两个值`3`和`2`，那么`b`的值为`2`
>
> ```cangjie
> func add(a: Int32, b!: Int32 = 1): Int32 { a + b }
> 
> add(3)			// invoke add(3, 1), return 4
> add(3, b: 2)	// return 5
> ```

了解过C++的话, 仓颉中存在默认值参数的使用, 也没有太大区别

> - 类或接口中被 `open` 关键字修饰的函数不允许有可选参数
>
> - 操作符函数不允许有可选参数
>
> - 匿名函数（lambda 表达式）不允许有可选参数
>
> - 函数参数默认值中引入的名字从静态作用域中获得，即引入的名字为函数定义时可访问到的名字
>
> - 函数参数默认值中引入的名字在函数定义时可访问即可，无需和函数本身的可访问性一致
>
> - **函数参数和其默认值不属于该函数的函数体**
>
> - 参数默认值在函数调用时求值，而非在函数定义时求值
>
> - 规定, 函数调用时参数求值顺序是按照定义时顺序从左到右，**函数参数的默认值可以引用定义在该参数之前的形参**
>
> - 函数调用时，**通过函数名调用可以使用默认值，通过变量名调用不支持使用默认值**
>
>     ```cangjie
>     // 编译时错误
>     // func f(a: Int32, b!: Int32 = 2, c: Int32): Int32 { ... }
>         
>     // OK.
>     func f1(a: Int32, b: Int32, c!: Int32 = 3, d!: Int32 = 4): Int32 { 
>         a + b + c + d
>     }
>         
>     func test() {
>         f1(1, 2)			// 10,  f1(1, 2, 3, 4)
>         f1(1, 2, c: 5)		// 12,  f1(1, 2, 5, 4)
>     }
>     ```
>
>     ```cangjie
>     /* 在默认值中引入的名称，不需要具有与函数相同或更严格的可访问性 */
>     var x = 10
>     var y = 10
>     func g() {}
>     public func f2(a!: Int64 = x * 2 + y, b!: ()->Unit = g) {}  // OK.
>         
>     class AAA {
>         static private var x = 10
>         
>         func f(a!: Int64 = x) { // OK, public 方法可以使用私有静态字段
>             print("${a}")
>             x = x + 10
>             print("${x}")
>         }
>     }
>     ```
>
>     ```cangjie
>     /* 
>     调用函数时，函数声明中的名称可以使用默认值
>     使用变量名调用函数时，参数不能是可选的, 即不支持使用默认值
>     */
>     func f1(): (Int64) -> Unit { g1 }
>         
>     func g1(a!: Int64 = 42) {
>         print("g1: ${a}")
>     }
>         
>     let gg1 = f1()   
>     let x = gg1()    // Error, 不能省略参数
>     let gg3 = g1     
>     let a = gg3()    // Error, 不能省略参数
>     ```

文档中有两句比较不明确的介绍:

> - 函数参数默认值中引入的名字从静态作用域中获得，即引入的名字为函数定义时可访问到的名字
> - 函数参数默认值中引入的名字在函数定义时可访问即可，无需和函数本身的可访问性一致

这两句话的意思其实是:

函数参数的默认值表达式中所引用的名字(变量、函数等)，按照**静态作用域规则**在**函数定义处**进行解析, 即 **解析的是函数定义时可以看到的名字, 而不是调用时可能可以看到的名字**

只要在该位置这些名字是可访问的（无论其访问权限是 `private` 还是 `public`），就可以使用, **不要求默认值中引用的名字具有 与函数定义本身的访问级别（如 `public`） 相同或更宽松的访问权限**

在例子中就是, `public`成员函数可以引用`private`成员变量作为参数的默认值

> 由于函数的形参和其默认值不属于该函数的函数体
>
> 所以下面例子中的 `return` 表达式缺少包围它的函数体
>
> 它既不属于外层函数 `f`（因为内层函数定义 `g` 已经开始），也不在内层函数 `f` 的函数体中：
>
> ```cangjie
> func f() {
>     func g(x! :Int64 = return) { // Error: return 必须在函数体内使用
>         0
>     }
>     1
> }
> ```

这个意思是, 仓颉中函数体 就只是`{}`的内容, 参数列表什么的都是不算的

### 函数体

> 函数体由一个 `block` 组成

#### 局部变量

> 在仓颉编程语言中，允许在函数体内定义变量，将其称为局部变量
>
> 变量可以用`var`修饰为可变变量或`let`修饰为不可变变量
>
> ```cangjie
> func foo(): Unit {
>     var a = 1
>     let b = 1
> }
> ```

熟悉C/C++, 对局部变量再熟悉不过了

#### 嵌套函数

> 在仓颉编程语言中，允许在函数体内定义函数，将其称为嵌套函数
>
> **嵌套函数中可以捕获外部函数中定义的变量或其他嵌套函数**
>
> 嵌套函数支持递归
>
> ```cangjie
> func foo(): Unit {
>     func add(a: Int32, b: Int32) {
>     	a + b
>     }
> 
>     let c = 1
> 
>     func nest(): Unit {
>         print("${c}")		// 1
>         var b = add(1, 2)	// b = 3
>     }
> }
> ```

仓颉中, 嵌套函数就是**在函数体内定义函数**

嵌套函数 可以捕获外部函数定义的变量或其他嵌套函数, 其实与顶层作用域定义函数相似

### 函数的返回类型

> 函数的返回类型有以下情况：
>
> - 任何类型
>
> - **返回值为元组的函数**：可以使用元组类型作为函数的返回类型，将多个值作为一个复合返回值返回
>
>     如以下例子，它的返回是一个元组`(a, b)`，返回类型是`(Int32, Int32)`
>
>     ```cangjie
>     func returnAB(a: Int32, b: Int32): (Int32, Int32) { (a, b) }
>     ```
>
> - **函数类型作为返回类型**：可以使用函数类型作为另一个函数的返回类型
>
>     如下示例, 在`:`后紧跟的是`add`函数的类型`(Int32, Int32) -> Int32`
>
>     ```cangjie
>     func returnAdd(a: Int32, b: Int32): (Int32, Int32) -> Int32 {
>         return {a, b => a + b}    // 返回一个 lambda 表达式
>     }
>     ```

函数作为仓颉语言中的一等公民, 是可以作为返回值的, 返回值类型也就有函数类型

函数返回元组, 实现多个返回值返回

> **如果指定函数的返回类型**，则在函数定义的参数列表后使用 `:Type` 指定
>
> 此时要求函数体的类型、函数体中所有 `return e` 表达式中 `e` 的类型是标注的类型（`Type`）的子类型，否则编译报错
>
> ```cangjie
> class A {}
> class B <: A {}
> // Return is not written.
> func add(a: Int32, b: Int32): B {
>     var c = a + b
>     if (c > 100) {
>         return B()
>     } else {
>         return A() // 编译错误，因为 A 不是 B 的子类型
>     }
> }
> ```
>
> **特别地，指定返回类型为 Unit 时**（如 `func f(x:Bool):Unit { x }`），则编译器会在函数体中所有可能返回的地方**自动插入表达式 `return ()`**，使得函数的返回类型总是为 `Unit` 
>
> 示例如下：
>
> ```cangjie
> func Column(c: (Data) -> Unit): Unit {
> 	2
> } 	// return () 会被自动插入
> 
> func Column(c: (Data) -> Unit) {
> 	2
> }	// 返回值类型为 Int64
> ```

仓颉的函数还比较有意思, 如果函数返回值类型是`Unit`, 编译器会在函数体有可能返回的地方 自动添加`return ()`

所以此时, 可以不用显式书写`return ()`

> **如果不指定函数的返回类型** ，则编译器会根据函数体的类型以及函数体中的所有 `return` 表达式来共同推导出函数的返回类型
>
> 此过程不是完备的，如遇到（互）递归函数而无法推导它们的返回类型时，编译报错
>
> （注意：不能为没有函数体的函数推导其返回类型）
>
> 函数的返回类型推导规则如下：
>
> **函数体是表达式和声明的序列**，我们将**序列的最后一项的类型记为 `T0`**（若块的最后一项是表达式，则为表达式的类型；若最后一项为声明，则 `T0 = Unit`），再将**函数体中所有 `return e` （包括所有子表达式中的 `return e`）表达式中 `e`  的类型记为 `T1 ... Tn`**，则函数的返回类型是 `T0, T1, ..., Tn`的最小公共父类型
>
> 如果不存在最小公共父类型，则产生一个编译错误
>
> 示例如下：
>
> ```
> open class Base {}
> class Child <: Base {}
> 
> func f(a: Rune) {
>     if (false) {
>         return Base()
>     }
>     return Child()
> }
> ```
>
> - 函数体的类型是块的最后一项的类型，即 `return Child()` 的类型，其类型为 `Nothing`
> - 第一个 `return e` 表达式 `return Base()` 中 `e` 的类型是 `Base`
> - 第二个 `return e` 表达式 `return Child()` 中 `e` 的类型为 `Child`
> - 由于 `Nothing`, `Base`, `Child` 三者的最小公共父类型是 `Base`，所以该函数的返回类型为 `Base`
>
> 注：函数的返回值具有 `let` 修饰的语义

仓颉中, 如果函数定义未指定返回值类型, 那么编译器将自动推导返回类型

**推导过程为:**

1. **记录块中 最后一个表达式 或 声明的类型: `T0`**
2. **记录所有 `return e` 表达式中, `e`的类型为`T1, T2, T3, ...`**
3. **找`T0, T1, T2, T3, ...`的最小公共父类型, 作为函数的返回类型**

仓颉中, 函数的**返回值不能修改**, 具有`let`修饰的语义

### 函数声明

> 仓颉编程语言中，函数声明和函数定义的区别是，前者没有函数体
>
> 函数声明的语法如下：
>
> ```
> functionDeclaration
>     : functionModifierList? 'func'
>     identifier 
>     typeParameters?
>     functionParameters
>     (':' type)?
>     genericConstraints?
>     ;
> ```
>
> 函数声明可以出现在抽象类，接口中

仓颉中的函数声明与C/C++中的函数声明有些不同

C/C++中的函数声明, 只是声明一下函数的符号, 此函数是否已经被实现是不确定的

但仓颉中的函数声明, 好像也只是证明一下函数的符号, 且**只能出现在抽象类或接口中**, 这意味着 **仓颉中的函数声明, 表示这个函数一定没有被实现**

**所以在之后的继承或接口实现中, 必须要实现声明的函数**

仓颉中函数的声明 与 函数定义的区别, 就是没有函数体

### 函数的重定义

> 对于非泛型函数，在同一个作用域中，参数类型完全相同的同名函数被视为重定义，将产生一个编译错误
>
> 以下几种情况要格外注意：
>
> - 同名函数即使返回类型不同也构成重定义
>
> - 同名的泛型与非泛型函数永不构成重定义
>
> - 在继承时，对于子类中的一个与父类同名且参数类型完全相同的函数，若其返回类型是父类中的版本的子类型，则构成覆盖，也不构成重定义
>
>     这是因为子类与父类作用域不同
>
> 对于两个泛型函数，如果重命名一个函数的泛型形参后，其非泛型部分与另一个函数的非泛型部分构成重定义，则这两个泛型函数构成重定义
>
> 举例如下：
>
> 1. 下面这两个泛型函数构成重定义，因为存在一种 `[T1 |-> T2]` 的重命名（作用到第一个函数上），使得两个函数的非泛型部分构成重定义
>
>     ```cangjie
>     func f<T1>(a: T1) {}
>     func f<T2>(b: T2) {}
>     ```
>
> 2. 下面这两个泛型函数不构成重定义，因为找不到上述的一种重命名
>
>     ```cangjie
>     func f<X,Y>(a:X, b:Y) {}
>     func f<Y,X>(a:X, b:Y) {}
>     ```
>
> 3. 下面的这两个泛型函数构成重定义，因为存在一种 `[X |-> Y, Y |-> X]` 的重命名使得两个函数的非泛型部分构成重定义
>
>     ```cangjie
>     func f<X,Y>(a:X, b:Y) {}
>     func f<Y,X>(a:Y, b:X) {}
>     ```
