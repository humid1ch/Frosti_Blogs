---
title: '从零接触C语言(初览)-XI: 指针'
description: 'C语言提供了一种完全不受限制的内存直接访问能力, 那就是指针. 它是自由但极度危险的'
pubDate: '2025-09-03'
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250710215328038.webp'
categories:
    - Blogs
tags:
    - C
    - 从零开始接触C语言
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

import Error from "../../components/mdx/Error.astro";

import Kbd from "../../components/mdx/Kbd.astro"

<Warning>

如果你从未接触过C语言, 那么我建议你先阅读前面的文章:

[📌从零开始接触C语言](https://www.humid1ch.cn/blog/tag/从零开始接触C语言)

</Warning>

## 指针

有许多人说, **指针**是C语言中最难的知识点, 说它抽象、难以理解

也说**指针**是造成C语言不安全的原因之一, 说它危险、不受控制

但也有许多人说, **指针**是C语言的魅力所在, 说它高效、灵活自由

**指针**几乎是所有C语言使用者心中一个又爱又恨的角色

那么, 究竟什么是**指针**?

### 内存 **

要理解C语言的指针, 就必须要先了解一个概念: **内存**

可能有人会问: 是手机上 `8G+128G` `12G+256G` `16G+512G` 配置里, `128G` `256G` `512G`的"内存"吗?

不是, 严格意义上来讲, 手机上的`128G` `256G`等不叫内存, 前面的`8G` `12G` `16G`才叫内存

**内存, 是电脑上的内存条的内存, 是手机上的运行内存, 通常也被称为RAM**

而手机常见配置里的`128G` `256G` `512G`, 以及电脑上的硬盘等, 应该被称为外存

不谈手机, 电脑系统中, 你可以很简单的的看到自己的电脑内存是多大的、现在已经用了多少:

1. `Linux`

    终端直接输入`free`并回车:

    ![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250903174717592.webp)

    `total`, 就是总可用内存

    `used`, 就是已用内存

    `free`, 就是空闲可用内存

2. `Windows`

    可以直接打开任务管理器查看当前的内存使用状态:

    ![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250903174858961.webp)

当然, 这些不是重点

为什么理解C语言的指针, 要先理解**内存**呢?

因为, 在现代通用计算机中, 所有的C语言代码编译为程序之后, 在运行时, 都是运行在内存上的

而指针, 则是C语言提供的一种可以直接操作内存的机制

<Info>

这里涉及到的内存, 均不是直接指物理内存, 而是指由操作系统映射、管理的内存, 暂时不需要过于关注

但要注意到: 如果不涉及到操作系统内核的开发, 内存不是任何语言所拥有的东西, 所有语言能够访问、操作的内存任何时候都是操作系统层面的

类似什么 C语言的内存模型、C++的内存模型等, 实际上说的都是对应语言程序运行之后, 操作系统对程序分配的内存模型

总结一句话, **在不涉及操作系统内核开发的前提下, 内存永远是操作系统的, 而不属于任何语言, 语言也不拥有内存模型**

</Info>

当一个程序需要运行的时候, 为了程序能够正常的运行, 操作系统就要给程序分配一块内存, 让程序的代码、数据能够存放在内存中, 然后程序才能运行起来

一般情况下, 内存是由操作系统分配管理的

为了有效地使用内存, 操作系统会将内存划分为一块一块的内存单元, **每个内存单元是1个字节**

为了更好地管理、有效地访问内存, 操作系统还会**对每个内存单元进行唯一编号, 内存单元的编号就是我们常说的 内存单元的地址, 即 内存地址**

简单用图片理解, 内存可以看作是这样的:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250904110310368.webp)

### 什么是指针? **

当程序被加载运行后, 它的代码和数据都会被加载到内存中

换句话说, 操作系统会为程序分配若干内存单元, 并把程序的"代码"和"数据"存放到里面

所以, 以C语言程序的角度来看, 我们在代码中定义的各种变量, 也会被加载到内存中

且不同数据类型占用内存的大小是不同的: `char`类型变量只需要占用1字节(即 1个内存单元), `int`类型的变量需要占用连续的4字节(即 4个连续的内存单元)

上面介绍到, 操作系统会对每一个内存单元都进行编号, 这个编号就是内存单元的地址

**而, C语言规定 以变量所占用的第一个内存单元的地址作为该变量的地址, 且每个变量都有属于自己的地址**

而 ***指针, 就是C语言提供的一种能够存储并操作这些地址的机制***

指针, 可以存储地址并访问地址, 这种能力看起来和变量很相似

**事实上, 指针本质就是一种变量, 不过与普通变量不同的是, 指针存储的是地址这种特殊数据, 而普通变量存储的是特定类型的数据**

### 变量的地址

在正式开始使用指针之前, 我们先来看一下变量是否有自己的地址

其实很简单, 在[介绍操作符的文章中](https://www.humid1ch.cn/blog/getting-started-with-c-language-viii#heading-9)有一个操作符是`&取地址`, 我们可以用这个操作符取变量的地址, 并打印显示:

```c
#include <stdio.h>

int main() {
    int val = 10;
    printf("val addr: %p\n", &val);

    return 0;
}
```

这段代码编译运行的结果是:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250904115720052.webp)

从结果看到, `val`确实存在地址`0x7fffe135589c`

### 指针的定义

指针是一种变量, 但它不是普通的变量, 它与普通变量的定义也有一些差别

在[介绍操作符的文章中](https://www.humid1ch.cn/blog/getting-started-with-c-language-viii#heading-9)有一个操作符是`*`, 它可以用来定义指针

```c
数据类型* 标识符;
```

没错, 定义指针变量与定义普通变量只有一个区别, 那就是`*`

**定义变量时, 在数据类型之后加上`*`, 定义的就是指针变量**

```c
char* pS = NULL;
int* pI = NULL;
long* pL = NULL;
```

向上面这样, 就定义了三种类型的指针变量: `char*` `int*` `long*`, 且均赋值为`NULL`

**指针变量的类型, 就分别对应`char*` `int*` `long*`**

<Info>

**`NULL`是C语言标准提供的一个宏定义, 在C语言中表示空地址、空指针**

在C语言中, 其实就是 **`0`强制转换为空指针**

```c
#define NULL ((void*)0)
```

</Info>

当然, 除了给指针赋值为`NULL`之外, 我们还可以使用`取地址符&`, 取出已有变量的地址, 存储到指针变量中

需要注意的是, 普通变量和指针变量的类型要一致, 具体原因不在本篇说明

```c
#include <stdio.h>

int main() {
    int val = 20;
    int* pVal = &val;
    printf("val: %d, addr: %p\npVal: %p\n", val, &val, pVal);
    
    return 0;
}
```

这段代码, 定义`int`类型变量`val`, 取变量`val`的地址 并赋值给 定义的`int`类型指针`pVal`

并依次打印: `val`的值, `val`的地址, `pVal`的值

代码的编译运行结果为:

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250904170646227.webp)

从结果看到: `&val`取到的地址是`0x7ffc810495e4`, 而`pVal`的值也是`0x7ffc810495e4`

### 指针的使用

