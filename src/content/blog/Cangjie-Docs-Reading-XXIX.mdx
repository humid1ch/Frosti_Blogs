---
title: "仓颉文档阅读-开发指南II: 基本概念"
pubDate: "2025-10-21 23:31:11"
description: "仓颉文档阅读的开发指南部分, 本篇文章介绍一些仓颉语言的一些基本概念"
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250929154944807.webp'
categories: 
    - Blogs
tags:
    - 开发语言
    - 仓颉
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

import Question from "../../components/mdx/Question.astro";

<Info>

阅读文档版本:

语言规约 [Cangjie-0.53.18-Spec](https://cangjie-lang.cn/docs?url=/0.53.18/Spec/source_zh_cn/Chapter_01_Lexical_Structure(zh).html)

具体开发指南 [Cangjie-LTS-1.0.3](https://cangjie-lang.cn/docs?url=/1.0.3/index.html)

在阅读 了解仓颉的语言规约时, 难免会涉及到一些仓颉的示例代码, 但 我们对仓颉并不熟悉, 所以可以用[仓颉在线体验](https://cangjie-lang.cn/playground)快速验证

有条件当然可以直接[配置Canjie-SDK](https://cangjie-lang.cn/download/1.0.1)

</Info>

<Warning>

博主在此之前, 基本就只接触过C/C++语言, 对大多现代语言都没有了解, 所以在阅读过程中遇到相似的概念, 难免会与C/C++中的相似概念作类比, 见谅

</Warning>

<Warning>

在阅读仓颉编程语言的开发指南之前, 已经大概阅读了一遍 仓颉编程语言的语言规约，已经对仓颉编程语言有了一个大概的了解

所以在阅读开发指南时，不会对类似：类、函数、结构体、接口等解释起来较为复杂名称 做出解释

</Warning>

> 此样式内容, 表示文档原文内容

## 基本概念

### 标识符

> 在仓颉编程语言中，开发者可以给一些程序元素命名，这些名字被称为“标识符”
> 
> 学习标识符之前，需要了解一些 `Unicode` 字符集概念
> 
> 在 `Unicode` 标准中，`XID_Start` 和 `XID_Continue` 属性用于标记可以作为 `Unicode` 标识符（`Identifier`）的起始字符和后续字符，其详细定义请参见 `Unicode` 标准文档
> 
> 其中， `XID_Start` 包含中文和英文等字符，`XID_Continue` 包含中文、英文和阿拉伯数字等字符
> 
> 仓颉语言使用 `Unicode` 标准 `15.0.0`

标识符，如果你接触过任何一个编程语言，一定了解什么是标识符

比如：变量名，对象名，函数名，结构体名，类名，宏定义名等等，由开发者 为标识某个元素 而起得名字，就是标识符

如果是C++语言，C++11之后的标准中也使用`Unicode`标准作为标识符命名可用的字符

`Unicode`的`XID_Start`可作为标识符的起始字符，比如：

1. `ASCII`字符

    `A`, `B`, `C`, `...`

    `a`, `b`, `c`, `...`

2. 带重音的拉丁字母

    `á`, `ñ`, `ö`, `ü`, `ç`, `...` 

3. 希腊字母

    `α (U+03B1)`, `β (U+03B2)`, `Γ (U+0393)`, `...`

4. 中文汉字

    `中 (U+4E2D)`, `文 (U+6587)`, `变 (U+53D8)`, `...`

5. `...`

`Unicode`的`XID_Continue`可作为标识符的后续字符，比如：

1. 数字

    `0`, `1`, `...`, `9`

    全角数字：`０ (U+FF10)`, `１ (U+FF11)`

    阿拉伯-印度数字：`٠ (U+0660)`, `١ (U+0661)`

2. 下划线

    `_ (U+005F)`

3. 连接符/连字符类（部分）

    `‿ (U+203F, undertie)`

    `⁀ (U+2040, character tie)`

    `⁔ (U+2054, inverted undertie)`

    但注意：**普通连字符 `- (U+002D)` 不是 `XID_Continue`！**

4. 所有`XID_Start`字符

5. `...`

> 仓颉编程语言的标识符分为**普通标识符**和**原始标识符**两类，它们遵从不同的命名规则
> 
> 普通标识符不能和仓颉关键字相同，其取自以下两类字符序列：
> 
> - 由 `XID_Start` 字符开头，后接任意长度的 `XID_Continue` 字符
> 
> - 由一个`_`开头，后接至少一个 `XID_Continue` 字符

虽然`_`是`XID_Continue`标识符，但也可以作为标识符的起始字符

按照上面的简单介绍，数字和一些连接符是无法作为标识符的起始字符的

> 仓颉把所有标识符识别为 `Normalization Form C (NFC)` 后的形式
> 
> 两个标识符如果在 `NFC` 后相等，则被认为是相同的标识符
> 
> 例如，以下每行字符串都是合法的普通标识符：
> 
> ```cangjie
> abc
> _abc
> abc_
> a1b2c3
> a_b_c
> a1_b2_c3
> 仓颉
> __こんにちは
> ```
> 
> 以下每行字符串都是不合法的普通标识符：
> 
> ```cangjie
> ab&c          // Error, & 不是 XID_Continue 字符
> 3abc          // Error, 阿拉伯数字不是 XID_Start 字符，因此，数字不能作为起始字符
> _             // Error, _ 后至少需要有一个 XID_Continue 字符
> while         // Error, while 是仓颉关键字，普通标识符不能使用仓颉关键字
> ```
> 
> **原始标识符**是在普通标识符或仓颉关键字的首尾加上**一对反引号**，主要用于将仓颉关键字作为标识符的场景
> 
> 例如，以下每行字符串都是合法的原始标识符：
> 
> ```cangjie
> `abc`
> `_abc`
> `a1b2c3`
> `if`
> `while`
> `à֮̅̕b`
> ```
> 
> 以下每行字符串，由于反引号内的部分是不合法的普通标识符，所以它们整体也是不合法的原始标识符：
> 
> ```cangjie
> `ab&c`
> `3abc`
> ```

仓颉中，以`XID_Start`和`XID_Continue`组成的普通标识符, 普通标识符禁止与仓颉语言的关键字相同

仓颉中，除普通标识符外, 还可以在普通标识符首尾两端加上一对'\`', 表示**原始标识符**，原始标识符'\`'内的内容可以与仓颉关键字相同

### 程序结构

> 通常，开发者会在扩展名为 `.cj` 的文本文件中编写仓颉程序，这些程序和文件也被称为**源代码和源文件**
> 
> 在程序开发的最后阶段，这些源代码将被编译为特定格式的二进制文件

扩展名，一般是用来标识文件类型的，比如：`.txt`是文本文件，`.exe`是`Windows`平台上的可执行程序文件, `.md`是`Markdown`文件等

不同的编程语言，一般都会有自己的源代码文件扩展名，比如：

- C语言是`.c`, C++是`.cpp\.cc\.cxx`

- Golang是`.go`

- Java是`.java`

- Python是`.py`

- Rust是`.rs`等

而仓颉就是`.cj`, 也就是说如果一个文件的扩展名是`.cj`，不阅读内容的情况下，你可以暂时将其看作仓颉语言的源代码文件

也可以说，仓颉代码一般就写在`.cj`文件中

```cangjie
// hello.cj 
main() {
    println("你好，仓颉！")
}
```

> 在仓颉程序的**顶层作用域**中，可以定义一系列的变量、函数和自定义类型（如 `struct`、`class`、`enum` 和 `interface` 等），其中的变量和函数分别被称为**全局变量**和**全局函数**
> 
> 如果要将仓颉程序编译为可执行文件，需要在顶层作用域中定义一个 **`main` 函数作为程序入口**，它可以有 `Array<String>` 类型的参数，也可以没有参数，它的返回值类型可以是整数类型或 `Unit` 类型
> 
> > 注意：
> > 
> > 定义 `main` 函数时，不需要写 `func` 修饰符
> > 
> > 此外，如果需要获取程序启动时的命令行参数，可以声明和使用 `Array<String>` 类型参数

仓颉语言中，`main`函数被作为程序的入口，这与C/C++一致

`main`函数不能使用`func`修饰符，可以有`Array<String>`类型的参数，返回值类型可以是`Uint`或任意整型

```cangjie
main(): Int64 {
    println("hello world")
    return 0
}

main(argv: Array<String>): Unit {
    println("hello world")
}
```

**没有`main`函数的代码，无法编译出一个可执行文件**

`main`函数需要被定义在顶层作用域, 关于顶层作用域：一个文件，什么内容也没有时，写入的代码就在顶层作用域，在`{}`内编写的代码就不在顶层作用域

![](https://humid1ch.oss-cn-shanghai.aliyuncs.com/20251022002842422.webp)

上图中，绿框**没有选中**的区域都是顶层作用域

> 例如，在以下程序中，在顶层作用域定义了**全局变量 `a`** 和**全局函数 `b`**，还有自定义类型 `C`、`D` 和 `E`，以及作为程序入口的 `main` 函数
> 
> ```cangjie
> let a = 2023
> func b() {}
> struct C {}
> class D {}
> enum E { F | G }
> 
> main() {
>     println(a)
> }
> ```
> 
> 在**非顶层作用域中不能定义上述自定义类型**，但可以定义变量和函数，称之为**局部变量**和**局部函数**
> 
> 特别地，对于定义在自定义类型中的变量和函数，称之为**成员变量**和**成员函数**
> 
> > 注意：
> > 
> > **`enum` 和 `interface` 中仅支持定义成员函数，不支持定义成员变量**
> 
> 例如，在以下程序中，在顶层作用域定义了全局函数 `a` 和自定义类型 `A`，在函数 `a` 中定义了局部变量 `b` 和局部函数 `c`，在自定义类型 `A` 中定义了成员变量 `b` 和成员函数 `c`
> 
> ```cangjie
> func a() {
>     let b = 2023
>     func c() {
>         println(b)
>     }
>     c()
> }
> 
> class A {
>     let b = 2024
>     public func c() {
>         println(b)
>     }
> }
> 
> main() {
>     a()
>     A().c()
> }
> ```
> 
> 运行以上程序，将输出：
> 
> ```shell
> 2023
> 2024
> ```

结构体、类、接口和枚举，在仓颉中只能定义在顶层作用域中，这些自定义类型内部，也可以定义变量和函数，被称为成员变量和成员函数

变量和函数可以在顶层和非顶层作用域定义

`main`函数作为程序的入口，程序运行时，只会执行直接或间接写在`main`函数中的语句

#### 变量

> 在仓颉编程语言中，一个变量由对应的变量名、数据（值）和若干属性构成，开发者通过变量名访问变量对应的数据，但访问操作需要遵从相关属性的约束（如数据类型、可变性和可见性等）
> 
> 变量定义的具体形式为：
> 
> ```cangjie
> 修饰符 变量名: 变量类型 = 初始值
> ```
> 
> 其中修饰符用于设置变量的各类属性，可以有**一个或多个**，常用的修饰符包括：
> 
> - 可变性修饰符：`let` 与 `var`，分别对应**不可变**和**可变**属性，可变性决定了变量 被初始化后其值还能否改变，仓颉变量也由此分为不可变变量和可变变量两类
> 
> - `const` 修饰符：`const` 是一种特殊的变量修饰符
> 
>     它用于声明常量，要求**在声明时必须初始化**，一旦被赋值，其值就不能被改变
> 
>     这与`let`修饰符类似，都具有不可变的特性，但`const` 在使用上有更严格的限制
> 
> - 可见性修饰符：`private` 与 `public` 等，影响全局变量和成员变量的**可引用范围**，详见后续章节的相关介绍
> 
> - 静态性修饰符：`static`，影响成员变量的存储和引用方式，详见后续章节的相关介绍
> 
> 变量均支持赋值操作符`（=）`，与类型无关
> 
> `let` 修饰的变量只能被赋值一次，即初始化；`var` 修饰的变量可以被多次赋值

变量，是编程语言中为存储、使用某个类型的数据创建的一个元素

举一个最简单的例子：

```cangjie
var value: Int64 = 20
```

这个代码，就创建了一个变量名为`value`的用于存储`Int64`类型数据的`var`可变变量，并给定了一个初始值`20`

之后，你就可以通过`value`使用存储在变量中的值, 目前是`20`, 你也可以通过`value = 30`以及类似的赋值操作，修改`value`变量的值

当然，如果是`let value`，那就只能赋值一次

仓颉中，你可以将变量看作**一个贴有变量名贴纸的数据**, 通过变量名就能访问数据

> 在定义仓颉变量时，**可变性修饰符是必要的**，在此基础上，还可以根据需要添加其他修饰符
> 
> - 变量名应是一个合法的仓颉标识符
> 
> - 变量类型指定了变量所持有数据的类型
> 
>     当初始值具有明确类型时，可以省略变量类型标注，此时编译器可以自动推断出变量类型
> 
> - 初始值是一个仓颉表达式，用于初始化变量，如果标注了变量类型，需要保证初始值类型和变量类型一致
> 
>     在**定义全局变量或静态成员变量时，必须指定初始值**
> 
>     在定义局部变量或实例成员变量时，可以**省略初始值，但需要标注变量类型**，同时要在此变量被引用前完成初始化，否则编译会报错
> 
> 例如，下列程序定义了三个 `Int64` 类型的变量（分别为不可变变量 `a`、可变变量 `b` 和 `const` 变量 `c` ）
> 
> 随后修改了变量 `b` 的值，同时将 `b` 的值赋值给`a`，并调用 `println` 函数打印 `a`，`b` 和`c` 的值
> 
> ```cangjie
> main() {
>     let a: Int64
>     var b: Int64 = 14
>     const c: Int64 = 13
>     b = 12
>     a = b                         // 由 let 修饰的变量只能赋值一次，即初始化
>     println("${a}, ${b}, ${c}")
> }
> ```
> 
> 编译运行此程序，将输出：
> 
> ```shell
> 12, 12, 13
> ```

在定义变量时，必须要从`var`、`let`、`const`中选择一个可变性修饰符进行修饰

分别对应可变变量(`var`)、不可变变量(`let`)以及常量变量(`const`)

变量名需要是一个合法的[标识符](#heading-1)

一个变量一定被定义出来，其类型就固定了，就只能用来存储此类型数据，如果是自定义类型 或许还可以存储其子类型

这与C/C++这种弱类型语言很不一样，C/C++中存在许多的隐式类型转换和强制类型转换，而仓颉因为强类型所以少了很多类型转换

