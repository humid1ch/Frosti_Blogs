---
title: "仓颉文档阅读-语言规约XVI: 常量求值"
pubDate: "2025-10-21 00:06:11"
description: "一直对仓颉挺感兴趣的, 但是一直没有去读一下文档, 慢慢看一看, 了解一下"
image: 'https://humid1ch.oss-cn-shanghai.aliyuncs.com/20250929154944807.webp'
categories: 
    - Blogs
tags:
    - 开发语言
    - 仓颉
---

import Info from "../../components/mdx/Info.astro";

import Warning from "../../components/mdx/Warning.astro";

import Question from "../../components/mdx/Question.astro";

<Info>

阅读文档版本:

语言规约 [Cangjie-0.53.18-Spec](https://cangjie-lang.cn/docs?url=/0.53.18/Spec/source_zh_cn/Chapter_01_Lexical_Structure(zh).html)

具体开发指南 [Cangjie-LTS-1.0.3](https://cangjie-lang.cn/docs?url=/1.0.3/index.html)

在阅读 了解仓颉的语言规约时, 难免会涉及到一些仓颉的示例代码, 但 我们对仓颉并不熟悉, 所以可以用[仓颉在线体验](https://cangjie-lang.cn/playground)快速验证

有条件当然可以直接[配置Canjie-SDK](https://cangjie-lang.cn/download/1.0.1)

</Info>

<Warning>

博主在此之前, 基本就只接触过C/C++语言, 对大多现代语言都没有了解, 所以在阅读过程中遇到相似的概念, 难免会与C/C++中的相似概念作类比, 见谅

</Warning>

> 此样式内容, 表示文档原文内容

## 常量求值

### `const`变量

> `const` 变量是一种特殊的变量，它**可以定义在编译时完成求值**，并且在运行时不可改变的变量
> 
> `const` 变量与 `let/var` 声明的变量的区别是**必须在定义时就初始化**，且必须用 `const` 表达式初始化
> 
> 因此 `const` 变量的类型只能是 `const` 表达式支持的类型
> 
> 与 `let/var` 一样，`const` 变量也支持省略类型
> 
> `const` 表达式见下文定义
> 
> ```cangjie
> const a: Int64 = 0                    // ok
> const b: Int64                        // error, b 为初始化
> const c = f()                         // error, f() 不是 const 表达式
> const d = 0                           // ok, d 的类型是 Int64
> 
> func f(): Unit {}
> ```
> 
> `const` 变量定义后可以像 `let/var` 声明的变量一样使用
> 
> 与 `let/var` 声明的变量不同，`const` 由于在编译时就可以得到结果，可以大幅减少程序运行时需要的计算
> 
> ```cangjie
> const a = 0
> 
> main(): Int64 {
>     let b: Int64 = a                  // ok
>     print(a)                          // ok
>     let c: VArray<Int64, $0> = []     // ok
>     return 0
> }
> ```
> 
> `const` 变量可以是全局变量，局部变量，静态成员变量
> 
> `const` 变量**不能在扩展中定义**
> 
> ```cangjie
> const a = 0                           // ok
> 
> class C {
>     const b = 0                       // error, const 成员字段必须由 static 修改
>     static const c = 0                // ok
> 
>     var v: Int64
> 
>     init() {
>         const d = 0                   // ok
>         v = b + c + d
>     }
> }
> 
> extend C {
>     const e = 0                       // error, const 不能在 extend 中定义
> }
> ```
> 
> `const` 变量可以访问对应类型的所有实例成员，也可以调用对应类型的所有**非 `mut`**实例成员函数
> 
> ```cangjie
> struct Foo {
>     let a = 0
>     var b = 0
> 
>     const init() {}
> 
>     func f1() {}
>     const func f2() {}
>     mut func f3() {
>         b = 123
>     }
> }
> 
> main(): Int64 {
>     const v = Foo()
>     print(v.a)                        // ok
>     print(v.b)                        // ok
>     v.f1()                            // ok
>     v.f2()                            // ok
>     v.f3()                            // error, f3 是 mut 函数
>     return 0
> }
> ```
> 
> `const` 变量初始化后该类型实例的所有成员都是 `const` 的（深度 `const`，包含成员的成员），因此不能被用于左值
> 
> ```cangjie
> struct Foo {
>     let a = 0
>     var b = 0
> 
>     const init() {}
> }
> 
> func f() {
>     const v = Foo()
>     v.a = 1                           // error
>     v.b = 1                           // error
> }
> ```

`const`修饰变量, 定义常量, 整个程序不允许修改次变量的值

`const`变量, 必须在定义时进行初始化

`const`可以修饰成员变量， 但必须是静态成员变量

`const`修饰一个实例, 此实例可以访问所有成员变量, 但只能访问非`mut`成员函数

`const`修饰一个实例, 此实例的所有成员变量默认会被`const`修饰, 禁止赋值(当左值)

### `const`表达式


> 某些特定形式的表达式，被称为 `const` 表达式，这些表达式**具备了可以在编译时求值的能力**
> 
> 在 `const` 上下文中，这些是唯一允许的表达式，并且始终会在编译时进行求值
> 
> 而在其它非 `const` 上下文，`const` 表达式**不保证在编译时求值**
> 
> 以下表达式都是 `const` 表达式
> 
> 1. 数值类型、`Bool`、`Unit`、`Rune`、`String` 类型的**字面量（不包含插值字符串）**
> 
> 2. 所有元素都是 `const` 表达式的 `array` **字面量（不能是 Array 类型）**，`tuple` **字面量**
> 
> 3. `const` 变量，`const` 函数形参，`const` 函数中的局部变量
> 
> 4. `const` 函数，包含使用 `const` 声明的函数名、符合 `const` 函数要求的 `lambda`、以及这些函数返回的函数表达式
> 
> 5. `const` 函数调用（包含 `const` 构造函数），该函数的表达式必须是 `const` 表达式，所有实参必须都是 `const` 表达式
> 
> 6. 所有参数都是 `const` 表达式的 `enum` 构造器调用，和无参数的 `enum` 构造器
> 
> 7. 数值类型、`Bool`、`Unit`、`Rune`、`String` 类型的算数表达式、关系表达式、位运算表达式，**所有操作数都必须是 `const` 表达式**
> 
> 8. `if`、`match`、`try`、控制转移表达式（包含 `return`、`break`、`continue`、`throw`）、`is`、`as`
> 
>     这些表达式内的表达式必须都是 `const` 表达式
> 
> 9. `const` 表达式的成员访问（不包含属性的访问），`tuple` 的索引访问
> 
> 10. `const init` 和 `const` 函数中的 `this` 和 `super` 表达式
> 
> 11. `const` 表达式的 `const` 实例成员函数调用，且所有实参必须都是 `const` 表达式

首先, 各类型的字面量都是`const`表达式

`const`修饰的各种函数、参数、变量等都是`const`表达式

各种元素是`const`表达式的运算表达式 等

`const`表达式应该不是很难区分, 除了`let`之外, 不能被修改的, 不能被当作左值的等

### `const`上下文

> `const` 上下文是一类特定上下文，在这些上下文内的表达式都必须是 `const` 表达式，并且这些表达式**始终在编译时求值**
> 
> `const` 上下文是指 **`const` 变量初始化表达式**



